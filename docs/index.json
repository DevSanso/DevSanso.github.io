[{"content":"코딩하던 도중에, 구조체의 변수값을 리턴하는 함수를 만들던 도중에 있던일을 적을라고 한다. 일단 구조체에 있는 문자열 변수를 읽는 함수를 제작했다 하자.\nstruct A { num : u32, s : String } impl A { fn get_string(\u0026amp;self) -\u0026gt; String { self.s } /***/ } fn main() { let object = A{num : 0,s : String::from(\u0026#34;\u0026#34;)}; let _copyS = object.get_string(); /***/ } 다른 언어에서 작성하던것처럼 문자열의 getter를 함수로 만들어 놓고 컴파일 해보니 이런 에러가 뜬다.\nCompiling playground v0.0.1 (/playground) error[E0507]: cannot move out of `self.s` which is behind a shared reference --\u0026gt; src/main.rs:7:9 | 7 | self.s | ^^^^^^ move occurs because `self.s` has type `String`, which does not implement the `Copy` trait For more information about this error, try `rustc --explain E0507`. error: could not compile `playground` due to previous error 아 러스트는 대입이 아닌 이동이니 그런걸수 있겠다고 생각할수 있지만, 정수형으로 함수를 작성하면 정상적으로 작동하는걸 알수있다.\nstruct A { num : u32, s : String } impl A { fn get_u32(\u0026amp;self) -\u0026gt; u32 { self.num } /***/ } fn main() { let object = A{num : 0,s : String::from(\u0026#34;\u0026#34;)}; let _copyS = object.get_u32(); /***/ } /* 경고창을 나오지만 컴파일 에러는 나오지 않는다. */ 그래서 찾아보니 Copy라고 복사하고 관련된 트레이드 인데, 해당 트레이드를 구현하는 타입들은 대입연산자(=)에서 묵시적으로 변수 이동이 아닌 변수 복사가 된다고 한다.\n즉 u32은 기본적으로 copy트레이드가 구현되 있지만, String 타입은 해당 트레이드 구현이 안되있다, 그래서 getter 함수에서는 값 이동으로 작동하는데, self가 참조형이여서 이동이 안된다고 컴파일 에러가 나는것같다. 그럼 참조형을 안쓰면 되는거 하면?, getter함수 호출후에 구조체 사용이 불가능한다는 문제가 있다.\nstruct A { num : u32, s : String } impl A { fn get_string(self) -\u0026gt; String { self.s } /***/ } fn main() { let object = A{num : 0,s : String::from(\u0026#34;\u0026#34;)}; let _copyS = object.get_string(); println!(\u0026#34;{}\u0026#34;,object.get_string()) /***/ } /* output Compiling playground v0.0.1 (/playground) error[E0382]: use of moved value: `object` --\u0026gt; src/main.rs:15:19 | 13 | let object = A{num : 0,s : String::from(\u0026#34;\u0026#34;)}; | ------ move occurs because `object` has type `A`, which does not implement the `Copy` trait 14 | let _copyS = object.get_string(); | ------------ `object` moved due to this method call 15 | println!(\u0026#34;{}\u0026#34;,object.get_string()) | ^^^^^^ value used here after move | note: this function takes ownership of the receiver `self`, which moves `object` --\u0026gt; src/main.rs:6:19 | 6 | fn get_string(self) -\u0026gt; String { | ^^^^ For more information about this error, try `rustc --explain E0382`. error: could not compile `playground` due to previous error */ 그래서 해결법을 몇시간들어 찾아봤는데, 문자열 타입이 Clone 트레이드(Copy트레이드랑 비슷한 기능) 구현을 지원한다고 한다. 즉 함수에서 clone()를 호출하면 해결된다.\nstruct A { num : u32, s : String } impl A { fn get_string(\u0026amp;self) -\u0026gt; u32 { self.s.clone() } /***/ } ","permalink":"https://devsanso.github.io/posts/rust/cant_move_refer_structure/","summary":"코딩하던 도중에, 구조체의 변수값을 리턴하는 함수를 만들던 도중에 있던일을 적을라고 한다. 일단 구조체에 있는 문자열 변수를 읽는 함수를 제작했다 하자.\nstruct A { num : u32, s : String } impl A { fn get_string(\u0026amp;self) -\u0026gt; String { self.s } /***/ } fn main() { let object = A{num : 0,s : String::from(\u0026#34;\u0026#34;)}; let _copyS = object.get_string(); /***/ } 다른 언어에서 작성하던것처럼 문자열의 getter를 함수로 만들어 놓고 컴파일 해보니 이런 에러가 뜬다.","title":"몇몇 타입이 구조체의 맴버변수를 리턴 못하는 이유"},{"content":"계기 코틀린으로 코딩하는도중 예전에 쓰던 exposed 프레임워크의 코드줄에서 궁금증이 생겼는데.\nimport org.jetbrains.exposed.sql.* import org.jetbrains.exposed.sql.transactions.transaction object Users : Table() { ... val name = varchar(\u0026quot;name\u0026quot;, length = 50) ... } transaction { .... .... Users.update({ Users.name eq \u0026quot;city\u0026quot;}) { it[name] = \u0026quot;bob\u0026quot; } } 이라는 코드줄이 있다고 할때, User 싱글톤 객체에 name에 infix 함수인 eq가 있다. 그럼 이걸 update함수 밖에서 써도 될까에서 시작해서 그렇게 작성해서 컴파일 해봤는데.\nimport org.jetbrains.exposed.sql.* import org.jetbrains.exposed.sql.transactions.transaction object Users : Table() { ... val name = varchar(\u0026quot;name\u0026quot;, length = 50) ... } transaction { .... .... val exist = Users.name eq \u0026quot;city\u0026quot; Users.update({ exist }) { it[name] = \u0026quot;bob\u0026quot; } } /* e: main.kt: (13, 32): Unresolved reference: eq */ 이러한 에러가 나왔다. 분명 update안에는 컴파일이 됬는데 밖에서 사용하면 해당 함수는 없다고 에러가 나온다. 그래서 찾아본 결과 코틀린의 확장함수랑 관련된걸 알게 됬다.\n저 에러를 해결하는 법은 import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq 추가하면 된다. 본문 및 설명 우선 사람의 이름과 나이를 출력하는 프로그램을 프로그래밍 한다고 치자.\nopen class Person { internal var name : String = \u0026quot;\u0026quot; internal var age : Int = 0 } 단순하게 사람을 추상화한 클래스이다. 이것을 빌더패턴을 사용하는 방식으로 작성한다고 치자. 그래서 평소에 다른언어에서 하던 방식으로 작성하였다.\npackage com.example.kotlinTest.hello class PersonBuilder(val person: Person) { fun name(n : String) :PersonBuilder { this.person.name = n return this } fun age(a : Int) : PersonBuilder { this.person.age = a return this } fun build() { print(\u0026quot;hi my name is : ${person.name}\\n\u0026quot;) println(\u0026quot;my age is : ${person.age}\\n\u0026quot;) } } import com.example.kotlinTest.hello.* fun main() { var builder = PersonBuilder(Person()) builder .name(\u0026quot;ahn\u0026quot;) .age(25) .build() } 이렇게 작성하고보니 비록 본인의 코딩실력이 좋지않아도 이정도면 괜찮지 않을까 싶었지만, 사실 코틀린은 다른언어보다 지원하는 문법들이 많았고 이것을 활용하면 더 보기 좋은 코드를 작성할수 있다고 한다. 그래서 찾아보니 infix 함수랑 리시버 함수가 있다고 한다.\n해당 함수들의 설명은 공식 문서에 가면 있으니 먼저 보고 오는게 좋다.\ninfix 함수 : https://kotlinlang.org/docs/functions.html#infix-notation\n리시버 함수 : https://kotlinlang.org/docs/lambdas.html#function-literals-with-receiver\n이것들을 활용하면 위의 update함수처럼 별도의 import가 없으면 안에서는 사용할수 있지만, 밖에서는 사용못하게 할수도 있다. 이제 infix,리시버들을 활용한 소스코드이다.\npackage com.example.kotlinTest.hello /* 본래 해당 객체안의 확장 함수들은, PersonMethod를 임포트 안하면 사용이 안된다. */ object PersonMethod { infix fun Person.age(other : Int) { this.age = other } infix fun Person.name(other : String) { this.name = other } } /* block 변수로 리시터 함수 리터럴을 받게 됨으로써, PersonMethod안의 함수들이 사용가능해 진다. */ fun build(person: Person,block : PersonMethod.(Person) -\u0026gt; Unit) { PersonMethod.block(person) print(\u0026quot;hi my name is : ${person.name}\\n\u0026quot;) println(\u0026quot;my age is : ${person.age}\\n\u0026quot;) } import com.example.kotlinTest.hello.build import com.example.kotlinTest.hello.Person fun main() { build(Person()) { it name \u0026quot;ahn\u0026quot; it age 25 } } 예시가 좋지 못하지만, 이렇게 소스코드를 작성할수가 있다. 즉 PersonMethod 객체를 임포트 안해도 Person 확장 함수를 사용할수 있다.\n위 계기의 소스코드 해결법처럼 확장함수가 정의된 import com.example.kotlinTest.hello.PersonMethod를 추가하면 밖에서도 사용이 가능하다. ","permalink":"https://devsanso.github.io/posts/kotlin/using_function_literals_with_receiver/","summary":"계기 코틀린으로 코딩하는도중 예전에 쓰던 exposed 프레임워크의 코드줄에서 궁금증이 생겼는데.\nimport org.jetbrains.exposed.sql.* import org.jetbrains.exposed.sql.transactions.transaction object Users : Table() { ... val name = varchar(\u0026quot;name\u0026quot;, length = 50) ... } transaction { .... .... Users.update({ Users.name eq \u0026quot;city\u0026quot;}) { it[name] = \u0026quot;bob\u0026quot; } } 이라는 코드줄이 있다고 할때, User 싱글톤 객체에 name에 infix 함수인 eq가 있다. 그럼 이걸 update함수 밖에서 써도 될까에서 시작해서 그렇게 작성해서 컴파일 해봤는데.\nimport org.jetbrains.exposed.sql.* import org.jetbrains.exposed.sql.transactions.transaction object Users : Table() { .","title":"리시버 있는 함수 리터럴 유용한 사용"},{"content":"코틀린으로 spring 프로젝트를 코딩하고 있는데, 데이터베이스를 사용해야해서 JetBrains(코틀린 만든회사)에서 만든 exposed 라는 sql프레임워크를 사용하게 되었다.\n그렇게 해당 라이브러리로 테이블 객체를 만들고, select를 수행하는 함수에서 where 문을 추가해야 하는 상황에서 infix 함수를 사용하게 되었다.\n일단 예시로 평소에 나는 이렇게 코딩하고 있었다\n/* ... ... ... */ data class User : Table() (val name : String,val age : Int,/*..*/) data class NameAndAge(/*..*/) fun selectUser() : List\u0026lt;NameAndAge\u0026gt; { //select 안에 where 관련 기능이 추가된다. return User.select({ User.name.eq(\u0026quot;name\u0026quot;).and(User.age.eq(12)) }).map({ NameAndAge(/*..*/) }) } 이렇게 selectUser함수를 작성하는도중 다른 기능이 필요하여 exposed 저장소에서 예제를 보는도중, 내가 작성한거랑 전혀 다른 예제가 있었다. 그전에 일단 infix함수가 무엇인가에 알아보자\ninfix function infix fun Int.shl(x: Int): Int { ... } // calling the function using the infix notation 1 shl 2 // is the same as 1.shl(2) 해당 예시는 공식문서에서 갖고온거다. 공식 문서에 설명에서는 함수에 infix 예약어를 표시함으로써 infix 표기법으로 사용할수가 있다고 한다.\n개인적인 감상으로썬 보통 내가 사용하는 함수표기법이 컴퓨터에 맞쳐졌다면, 이걸 사람이 더 알아보게 쉽게 코드를 작성할수 있게 한거같다고 느꼈다. 그리고 이러한 방식은 아까 사용했다는 sql프레임 워크에서도 유용하게 사용 됬는데, 위 코드를 infix 함수로 바꾸면 이렇게 변한다.\n/* ... ... ... */ data class User : Table() (val name : String,val age : Int,/*..*/) data class NameAndAge(/*..*/) fun selectUser() : List\u0026lt;NameAndAge\u0026gt; { return User.select { (User.name eq \u0026quot;name\u0026quot;) and (User.age eq 12) }.map { NameAndAge(/*..*/) } } 아까전 코드보다 더 좋게 변하였다.\n이렇게 하다보니 느낌점이 있다. 여러 프로그래밍 언어들 하다보면 각 언어의 장점들이 있는데, 여러개 쓰다보면 해당 장점들을 사용할 생각이 안들고 그저 다른언어에서 사용하던 평소느낌의 코딩 방식을 고수한다.\n그것이 좋을지도 모르지만, 각 언어의 장점들을 이용해 코드를 좀더 보기 좋게, 코드길이를 더 적게 할수도 있는 선택지를 포기하는 단점이 있다는걸 알았다. 그래서 앞으로 코딩할땐 언어의 특징들을 자세히 찾아보게 하는게 나을것같다.\n","permalink":"https://devsanso.github.io/posts/kotlin/useful_infix_fun/","summary":"코틀린으로 spring 프로젝트를 코딩하고 있는데, 데이터베이스를 사용해야해서 JetBrains(코틀린 만든회사)에서 만든 exposed 라는 sql프레임워크를 사용하게 되었다.\n그렇게 해당 라이브러리로 테이블 객체를 만들고, select를 수행하는 함수에서 where 문을 추가해야 하는 상황에서 infix 함수를 사용하게 되었다.\n일단 예시로 평소에 나는 이렇게 코딩하고 있었다\n/* ... ... ... */ data class User : Table() (val name : String,val age : Int,/*..*/) data class NameAndAge(/*..*/) fun selectUser() : List\u0026lt;NameAndAge\u0026gt; { //select 안에 where 관련 기능이 추가된다.","title":"코틀린 하면서 느낀 infix 유용함"},{"content":"이번 11월에 netcore 6이 정식버젼이 배포되면서 c#이 10으로 업그레이드 됬다고 하여, 무엇이 바끼었나 보려 가보았다.\nglobal using 추가 //example global using System; 해당 지시문이 추가되면, 프로젝트 안에서 어느 파일이든 바로 using이 적용된다. 또한 static, 별칭 지시문도 똑같이 적용이 가능한다고 하낟.\nglobal using static System.Console; global using Env = System.Environment; 또한 해당 지시문이 어떤 파일에 있든 상관없이 똑같이 적용되기에, 해당 게시글에선 Program.cs 혹은 globalusings.cs을 생성하여 그곳에 추가하려 권장하고 있다.\nrecord structs record라고 c#9에서 추가된 기능에서 좀더 다른 기능이 추가된걸로 보인다.\n살펴보니 코틀린에 있는 data class랑 비슷한 역할을 하는걸로 보인다.\n//c#10 이전 public record struct Car { public string Company { get; init; } public string Name { get; init; } } //c#10 이후 public record struct Car(string Company,string Name); 자세한건 record 문서에서 확인할수 있다.\n지금 c#보단 다른걸 하다보니, 지금으로썬 이해가 쉽게되고, 흥미로운 기능들은 저거 2개이다.\n물론 여러 기능들도 생겼다\n  Extended property patterns (c#8에 추가된 속성 패턴기능 확장)   Parameterless struct constructors and field initializers (init 접근자 초기화를 생성자에서 초기화하는게 아닌,필드 초기화시점에서 할수 있게 한거)   File-scoped namespaces (자세히는 모르겠지만, 네임스페이스를 괄호없이 사용하면서, 클래스 정의도 할수 있게 하는것같다.)   Natural types for lambdas (잘 몰랐던 사실인데, 원래 람다를 변수에 대입할때 델리게이트 혹은 Func등을 사용해야하는걸 이제 var 키워드도 가능하게 한거같다)   허나 내가 c#을 처음 봤을때가 6버젼일때고, 그 6버젼조차 다 모르는 마당에 이렇게 여러 기능들이 추가되니, 지금이라도 복습하지 않으면 앞으로 c#을 쳐다보기도 매우 힘든 언어가 될것같다. 말 그대로(..)\n더 많은 내용은 net core6의 새로운점에 다한 문서를 보면 될것이다.\n","permalink":"https://devsanso.github.io/posts/csharp/new_csharp_10/","summary":"이번 11월에 netcore 6이 정식버젼이 배포되면서 c#이 10으로 업그레이드 됬다고 하여, 무엇이 바끼었나 보려 가보았다.\nglobal using 추가 //example global using System; 해당 지시문이 추가되면, 프로젝트 안에서 어느 파일이든 바로 using이 적용된다. 또한 static, 별칭 지시문도 똑같이 적용이 가능한다고 하낟.\nglobal using static System.Console; global using Env = System.Environment; 또한 해당 지시문이 어떤 파일에 있든 상관없이 똑같이 적용되기에, 해당 게시글에선 Program.cs 혹은 globalusings.cs을 생성하여 그곳에 추가하려 권장하고 있다.\nrecord structs record라고 c#9에서 추가된 기능에서 좀더 다른 기능이 추가된걸로 보인다.","title":"c#10에서 추가된거"},{"content":"러스트로 코딩하는도중, 소스코드를 분리할 필요성을 느껴 별도의 모듈로 만들고나서 임포트 할려고 할때, 해당 프로젝트안의 로컬 모듈들을 어떻게 임포트 하는지, 기억하기 힘들어 따로 이렇게 글을 작성할 필요성을 느꼇다.\n러스트에서는 mod라는 키워드가 있는데, 해당 키워드는 두가지의 기능을 수행한다.\n c++.c#처럼 네임스페이스 비슷한 기능을 한다. 다른 모듈들을 인클루드 한다. 예시로 이런 코드가 있다고 치자  // path : src/main.rs  /* similar c++ namespace module { void hello() { std::cout \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { module::hello(); return 0; } */ mod module { pub fn hello() { println!(\u0026#34;hello world\u0026#34;); } } fn main() { module::hello(); } 해당 소스코드는 module이라는 모듈안의 hello 함수를 호출하는 소스코드 이다.\n이렇게 보면 네임스페이스랑 비슷하게 보이기도 한다. 허나 중요한건 이것이 아닌, 만약 module라는 모듈이 빈내용이면 어떻게 될까?\nmod module; fn main() {} //결과창 error[E0583]: file not found for module `module` --\u0026gt; src/main.rs:1:1 | 1 | mod module; | ^^^^^^^^^^^ | = help: to create the module `module`, create file \u0026quot;src/module.rs\u0026quot; or \u0026quot;src/module/mod.rs\u0026quot; For more information about this error, try `rustc --explain E0583`. error: could not compile `playground` due to previous error 경고창의 일부 내용에서 create file \u0026ldquo;src/module.rs\u0026rdquo; or \u0026ldquo;src/module/mod.rs\u0026rdquo; 나오는걸 볼때, 빈 mod이면 다른 파일을 임포트하는것을 볼수있다.\n즉 만약 소스코드를 모듈단위로 분리하고 싶다면 mod를 이용하는것이 좋다.\n참고  File hierarchy keyword  ","permalink":"https://devsanso.github.io/posts/rust/how_import_modules/","summary":"러스트로 코딩하는도중, 소스코드를 분리할 필요성을 느껴 별도의 모듈로 만들고나서 임포트 할려고 할때, 해당 프로젝트안의 로컬 모듈들을 어떻게 임포트 하는지, 기억하기 힘들어 따로 이렇게 글을 작성할 필요성을 느꼇다.\n러스트에서는 mod라는 키워드가 있는데, 해당 키워드는 두가지의 기능을 수행한다.\n c++.c#처럼 네임스페이스 비슷한 기능을 한다. 다른 모듈들을 인클루드 한다. 예시로 이런 코드가 있다고 치자  // path : src/main.rs  /* similar c++ namespace module { void hello() { std::cout \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { module::hello(); return 0; } */ mod module { pub fn hello() { println!","title":"모듈 임포트"},{"content":"러스트로 코딩하던 도중에 트레이드를 리턴해야하는 함수를 만들어야 하는 상황이 있었다. 그래서 go언어를 코딩하는것과 마찬가지로 리턴타입을 트레이드(go언어에선 인터페이스)로 하여 리턴 하는 함수를 작성후 컴파일 해본적이 있었는데 그때의 일을 적어볼려고 한다.\n//go 코드 예시 package main import \u0026#34;fmt\u0026#34; type Hi interface { hi() } type String struct { s string } func new_hi(s string) Hi { return \u0026amp;String{s} } func (s *String)hi() { fmt.Println(\u0026#34;hi : \u0026#34;s.s) } func main() { var str = \u0026#34;sunken ahn\u0026#34; new_hi(str).hi() } 이런한 기능을 하는 프로그램을 작성한다고 할때, 이것을 러스트로 재작성할려고 한다.\n그래서 내 생각대로 러스트 코드를 작성하게 되었다.\n//rust 코드 예시 trait Hi { fn hi(\u0026amp;self); } impl Hi for String { fn hi(\u0026amp;self) { println!(\u0026#34;hi : {}\u0026#34;,self); } } fn new_hi(val : String) -\u0026gt; Hi { return val; } fn main() { let name = String::from(\u0026#34;sunken ahn\u0026#34;); new_hi(name).hi(); } 이렇게 작성하고 컴파일 하니 에러메세지가 나타났다. 그래서 처음에는 이게 왜? 였다. 해당 에러가 리턴 타입 지정에서 에러가 나왓는데 다른언어들은 원하는 타입을 리턴하고 싶으면 함수에 리턴 타입을 지정하는데 말이다.\n그리고 찾아보니, rust의 컴파일 방식 때문인걸 알게 되었다. 러스트는 메모리 안전성을 위해 다른언어들과 다르게 컴파일 단계에서 메모리 관리하고 안전성을 추척한다. 그렇기에 메모리 관리를 위해 변수의 메모리 크기등을 컴파일러가 알아야 하는데, 트레이드는 이른바 일종의 여러 메소드의 묶음박스일뿐, 그 자체가 타입이 아니다. 그렇기에 변수의 메모리 크기의 정보가 없기에, 컴파일러는 해당 함수의 리턴값이 어느정도의 크기인지 알수없기에 컴파일 에러를 보내는것이다.\n그렇기에 다른방식으로 값을 리턴시키면 된다. 첫번째로 제너릭으로 함수 인수값(Hi를 구현한 String)을 받은후, 해당 인수타입으로 내보내는 방법. 두번째로 박스라는 러스트의 힙할당 구조체를 사용하여 리턴하는 방법. 그리고 내가 알고 있는 마지막 방법으로 impl trait를 리턴 타입으로 적어서 쓰는 방법이다. 참고 Traits: Defining Shared Behavior\n","permalink":"https://devsanso.github.io/posts/rust/how_return_trait/","summary":"러스트로 코딩하던 도중에 트레이드를 리턴해야하는 함수를 만들어야 하는 상황이 있었다. 그래서 go언어를 코딩하는것과 마찬가지로 리턴타입을 트레이드(go언어에선 인터페이스)로 하여 리턴 하는 함수를 작성후 컴파일 해본적이 있었는데 그때의 일을 적어볼려고 한다.\n//go 코드 예시 package main import \u0026#34;fmt\u0026#34; type Hi interface { hi() } type String struct { s string } func new_hi(s string) Hi { return \u0026amp;String{s} } func (s *String)hi() { fmt.Println(\u0026#34;hi : \u0026#34;s.s) } func main() { var str = \u0026#34;sunken ahn\u0026#34; new_hi(str).","title":"trait를 리턴하는 방법"},{"content":"프로그래밍 하는 도중 파일을 입출력 코드를 작성하는 상황이 있었는데, 여기서 \u0026ldquo;파일 입출력을 싱글 스레드 그리고 멀티 스레드중 어느것이 나을까?\u0026ldquo;라고 궁금중이 생겨서, 따로 코드를 작성하고 테스트했던것을 적어볼려고 한다.\n우선 나는 어느것이 성능이 좋을지 생각하면서 어떤 프로그램 요구서를 생각하고, 그것에 따라서 작성해보았다.\n프로그램 계획 요구 : 랜덤 해쉬값을 생성후, 해당값을 파일이름 그리고 파일내용으로 작성하여 특정폴더에 저장한다.  프로그램은 싱글,멀티스레드 선택값,폴더경로 그리고 파일 생성 갯수값을 인수로 입력받는다 해쉬값을 랜덤으로 생성한다 해당값으로 파일명으로 해서 생성후, 해당 파일에 해당값을 저장 이 행동을 생성 갯수값만큼 반복한다 반복이 완료후의 시간을 측정하고, 출력한다 프로그램 종료  그리고 해당 요구서를 토대로 코틀린으로 작성해보았다.\n//main.kt //메인 함수 import java.lang.Exception import kotlin.system.measureTimeMillis fun main(args: Array\u0026lt;String\u0026gt;) { val c = args.first().toInt() // 1 : 멀티스레드,2: 싱글스레드 val root = args[1] // 폴더 경로 val count = args[2].toInt() // 파일 생성 갯수 val fIO : IoTest = when(c) { 1 -\u0026gt; AsyncFileIO(count,root,4)// 스레드는 4개 생성후 사용 2 -\u0026gt; NonFileIO(count,root) else -\u0026gt; throw Exception(\u0026quot;not 1 and 2\u0026quot;) } val time = measureTimeMillis { fIO.run() } println(\u0026quot;time : ${time}(ms)\u0026quot;) } //IoTest.kt //추상클래스 abstract class IoTest constructor(protected val maxCount : Int,protected val root : String) { abstract fun run() } //NonFileIO.kt //싱글 스레드 작동 객체 import kotlin.io.* import java.io.File import java.nio.charset.Charset import java.util.UUID import java.nio.file.Paths class NonFileIO(maxCount: Int, root: String) : IoTest(maxCount, root) { override fun run() { var i = 0; var random_uuid = UUID.randomUUID().toString() while(i \u0026lt; maxCount) { var file = File(Paths.get(root,random_uuid).toString()) file.createNewFile() file.writeText(random_uuid, Charset.defaultCharset()) random_uuid = UUID.randomUUID().toString() i++ } } } //AsyncFileIO.kt //멀티스레드 작성 객체 import kotlinx.coroutines.* import kotlinx.coroutines.channels.Channel import java.io.File import java.nio.charset.Charset import java.nio.file.Paths import java.util.* class AsyncFileIO( maxCount: Int, root: String,private val tCount : Int) : IoTest(maxCount, root) { private suspend fun createWorker (channel : Channel\u0026lt;String\u0026gt;) { for(i in 1..tCount) { //해당 코드를 사용하면 자바내부에 스레드가 생성된다. CoroutineScope(Dispatchers.IO).launch { while(!channel.isClosedForSend) { if(channel.isEmpty)continue val msg = channel.receive() var file = File(Paths.get(root,msg).toString()) file.createNewFile() file.writeText(msg, Charset.defaultCharset()) } } } } override fun run() : Unit = runBlocking { val channel = Channel\u0026lt;String\u0026gt;() val job = async { createWorker(channel) } for(i in 1..maxCount) { var random_uuid = UUID.randomUUID().toString() channel.send(random_uuid) } channel.close() job.await() } } 간단 설명 이미지 이것을 토대로 10000개의 파일을 생성하는 테스트를 해본결과\u0026hellip;\n결과창    방식 시간표     싱글스레드 68.953s   멀티스레드 46.261s    이렇게 꽤 차이 나는 결과를 알게되었다.\n","permalink":"https://devsanso.github.io/posts/kotlin/thread_file_io_performance/","summary":"프로그래밍 하는 도중 파일을 입출력 코드를 작성하는 상황이 있었는데, 여기서 \u0026ldquo;파일 입출력을 싱글 스레드 그리고 멀티 스레드중 어느것이 나을까?\u0026ldquo;라고 궁금중이 생겨서, 따로 코드를 작성하고 테스트했던것을 적어볼려고 한다.\n우선 나는 어느것이 성능이 좋을지 생각하면서 어떤 프로그램 요구서를 생각하고, 그것에 따라서 작성해보았다.\n프로그램 계획 요구 : 랜덤 해쉬값을 생성후, 해당값을 파일이름 그리고 파일내용으로 작성하여 특정폴더에 저장한다.  프로그램은 싱글,멀티스레드 선택값,폴더경로 그리고 파일 생성 갯수값을 인수로 입력받는다 해쉬값을 랜덤으로 생성한다 해당값으로 파일명으로 해서 생성후, 해당 파일에 해당값을 저장 이 행동을 생성 갯수값만큼 반복한다 반복이 완료후의 시간을 측정하고, 출력한다 프로그램 종료  그리고 해당 요구서를 토대로 코틀린으로 작성해보았다.","title":"싱글,멀티 스레드 파일 입출력 성능 "},{"content":"자바스크립트를 공부하다보면 비동기 함수 사용이라고 setTimeout , Promise 그리고 async과 await를 배우게 된다. 허나 이러한 사용법이 있다고 하고, 어떤 상황에 어떻게 써야하는지는 자세히 모르는경우 가 많았고, 그리고 이번에 이 궁금점을 풀기위해 코드를 작성하다가 알게된 내용을 적어볼려고한다.\n보통 자바스크립트는 싱글 스레드이기 때문에 비동기api를 이용하여 멀티스레딩을 한다고 이야기를 한다. 결국 비동기로 병렬처리를 하는것처럼 보여도 결국 싱글스레드에서 모든일을 한다는것이다, 그럼 만약 여러 비동기 함수안에 처리시간이 많은 루프가 있으면 어떻게 될까?\n해당 궁금점을 알기위해 코드를 작성하기로 마음먹고, 다음과 같은 규칙과 목표를 세웠다.\n프로그램 규칙  웹페이지를 전송주고, 특정 데이터를 보내주는 서버를 만든다, 그리고 데이터는 0~1000사이의 정수이며, 데이터의 값은 랜덤이다. 웹사이트는 처음 로딩시 4개의 객체가 있고,각 객체만 무작위로 하나의 정수를 할당받는다. 각 하나의 객체는, 각자의 정수값이 서버로부터 받는 정수데이터값하고 동일할때까지 계속 서버에 데이터값을 요청한다. 만약 데이터가 동일하지 않으면 화면에 실패 횟수를 보여준다 하나의 객체가, 서버로부터 온 데이터랑 동일하면 활동을 멈춘다  설명이 부족해 보일수도 있기에, 일단 코드예시도 올리기로 결정했다.\n//server source code package main import ( \u0026#34;net/http\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;math/rand\u0026#34; ) func ramdonIntHandler(w http.ResponseWriter,r *http.Request) { var s = rand.Int() %1001 var conv = strconv.Itoa(s) w.WriteHeader(200) w.Write([]byte(conv)) } func main() { //www : 웹페이지가 저장되있는 폴더 \tfs := http.FileServer(http.FS(os.DirFS(\u0026#34;.\\\\www\u0026#34;))) http.Handle(\u0026#34;/\u0026#34;, fs) http.HandleFunc(\u0026#34;/random\u0026#34;,ramdonIntHandler) log.Println(\u0026#34;Listening on :3000...\u0026#34;) err := http.ListenAndServe(\u0026#34;:3000\u0026#34;,nil) if err != nil {log.Fatal(err)} } \u0026lt;!-- 웹페이지 html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;match number\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;section id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;switchBox box1\u0026#34;\u0026gt; \u0026lt;span\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;switchBox box2\u0026#34;\u0026gt; \u0026lt;span\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;switchBox box3\u0026#34;\u0026gt; \u0026lt;span\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;switchBox box4\u0026#34;\u0026gt; \u0026lt;span\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- 비동기로 서버로 요청하는 라이브러리--\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;./assets/js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;button onclick=\u0026#34;main();\u0026#34;\u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; const Box = function(className) { this.switch = false; this.num = parseInt((Math.random() * 1000)); this.className = className this.update = (data) =\u0026gt; { this.switch = this.num == data ? true : false; } let doc =document.querySelector(\u0026#34;.\u0026#34;+className + \u0026#34; \u0026gt; span\u0026#34;); return { //Promise.then을 이용한 함수  loop :async () =\u0026gt; { while(!this.switch) { axios({ method: \u0026#39;get\u0026#39;, url: \u0026#34;/random\u0026#34; }).then((value)=\u0026gt; { let d = parseInt(value.data); this.update(d); doc.textContent = parseInt(doc.textContent) + 1 }); } console.log(\u0026#34;done \u0026#34; + this.className); }, //setTimeout를 이용한 루프  loopSetTimeout : () =\u0026gt; { let body = () =\u0026gt; { axios({ method: \u0026#39;get\u0026#39;, url: \u0026#34;/random\u0026#34; }).then((value)=\u0026gt; { let d = parseInt(value.data); this.update(d); doc.textContent = parseInt(doc.textContent) + 1 if(!this.switch)setTimeout(body,10); }); } setTimeout(body,10); }, //await를 이용한 함수  loopAwait :async () =\u0026gt; { while(!this.switch) { let res = await axios({ method: \u0026#39;get\u0026#39;, url: \u0026#34;/random\u0026#34; }); let d = parseInt(res.data); this.update(d); doc.textContent = parseInt(doc.textContent) + 1; } console.log(\u0026#34;done \u0026#34; + this.className); }, getNum : () =\u0026gt; this.num } } function AllocBox(ele) { let element = new Box(ele); //element.loop();  //element.loopSetTimeout();  //element.loopAwait();  console.log(ele + \u0026#34; Box Number = \u0026#34; + element.getNum()); } const main = () =\u0026gt; { AllocBox(\u0026#34;box1\u0026#34;); AllocBox(\u0026#34;box2\u0026#34;); AllocBox(\u0026#34;box3\u0026#34;); AllocBox(\u0026#34;box4\u0026#34;); } 자바스크립트에는 각자 어떻게 작동되는지 알기위해 각 3개의 함수를 작성하고 테스트를 해본 결과 뜻밖에 결과가 나왔다.\n결론부터 말씀드리면, setTimeout과 await는 정상적으로 작동되는걸 확인되었다. 해당 결과는 await의 결과지만, setTimeout도 비슷하게 작동하였다. 그 대신 promise.then쪽은 예상과 다르게 작동했는데, 결과값이 다른것도 아닌 아예 웹페이지 자체가 작동을 멈추게 되었다. 새로고침, 페이지 종료창을 마우스로 클리해도 응답 자체가 되지 않았다. 우선 await부터 살펴보자, 사실 본래 await는 저렇게 객체들이 동시에 서버에 요청하기에 한꺼번에 숫자 횟수가 바끼는걸 볼수 있다. 사실 이건 본인이 예상했던 결과가 아니다.\n그 이유를 나열하자면\n 비동기로 처리해도 결국 하나의 스레드는 하나의 함수만 처리할수 있다. 그리고 실행중인 함수가 끝나야 이벤트큐에 들어있는 다음 비동기 함수를 실행할수 있다. 만약 처리하는 함수가 오래 걸리는 루프가 있을시, 해당 루프를 탈출하기 전까지 함수는 종료되지 않는다. 그렇기에 결국 한객체만 처리할수밖에 없는 상황이 된다.  위 조건에 맞는것이 바로 promise.then를 사용한 방법이다. 실제 함수 중간에 console.log 함수를 작성하여 테스트한 결과, 한 객체의 promise만이 수없이 작동되게 된다. 그렇게 이벤트 큐에 끊임없이 쌓이게되니 브라우저가 결국 먹통되었다고 추측하고 있다. 허나 그렇게 되지 않았고, 그 이유를 찾아본 결과, async함수에서 await블록으로 진입시, 해당 함수는 await블록에서 일시 정지되고, 다음 async함수가 실행되게 된다, 그후 일시정지된 함수가 다시 돌아오면 await가 처리 완료되면 async함수를 마저 처리하고, 만약 아직 완료가 안되면 또 일시 정지후 다음 함수가 실행된다는거다.\n정확한 내용을 알고싶으면 해당 사이트를 참고하면 좋을것이다.  mdn web docs stackoverflow question  ","permalink":"https://devsanso.github.io/posts/javascript/difference_between_await_and_then/","summary":"자바스크립트를 공부하다보면 비동기 함수 사용이라고 setTimeout , Promise 그리고 async과 await를 배우게 된다. 허나 이러한 사용법이 있다고 하고, 어떤 상황에 어떻게 써야하는지는 자세히 모르는경우 가 많았고, 그리고 이번에 이 궁금점을 풀기위해 코드를 작성하다가 알게된 내용을 적어볼려고한다.\n보통 자바스크립트는 싱글 스레드이기 때문에 비동기api를 이용하여 멀티스레딩을 한다고 이야기를 한다. 결국 비동기로 병렬처리를 하는것처럼 보여도 결국 싱글스레드에서 모든일을 한다는것이다, 그럼 만약 여러 비동기 함수안에 처리시간이 많은 루프가 있으면 어떻게 될까?\n해당 궁금점을 알기위해 코드를 작성하기로 마음먹고, 다음과 같은 규칙과 목표를 세웠다.","title":"await와 then의 작동 차이"},{"content":"julia에 dot 연산자라고, 배열안의 요소별로 각각 연산해주는것이 있다. 예시로 백터를 생성후 요소값들을 각각 하나씩 더하고 싶을때 보통은 for문등 방법을 사용하는게 보통이다.\njulia\u0026gt; x = [1,2,3,4,5] #output #5-element Vector{Int64}: # 1 # 2 # 3 # 4 # 5 julia\u0026gt; i = 1 julia\u0026gt; while i \u0026lt;= 5 x[i] = x[i]+2 global i += 1 end julia\u0026gt; x #output #5-element Vector{Int64}: # 3 # 4 # 5 # 6 # 7 허나 julia에서는 dot 연산자를 사용해 한줄코드로 간단하게 사용할수 있다.\njulia\u0026gt; x .+ 2 #output #5-element Vector{Int64}: # 3 # 4 # 5 # 6 # 7 또한 julia에서는 \u0026ldquo;@.\u0026ldquo;라는 매크로가 존재하는데, 계산식에 많은 dot(.)이 있을경우 표현식의 길이가 길어질수 있는데, 해당 매크로를 사용하면 dot를 각 연산자마다 사용할 필요가 없어져서, 표현식이 더 간결해질수 있다.\njulia\u0026gt; x = [1,2,3] #output #3-element Vector{Int64}: # 1 # 2 # 3 julia\u0026gt; 2 .* x.^2 .+ sin.(x) #output #3-element Vector{Float64}: # 2.8414709848078967 # 8.909297426825681 # 18.14112000805987 julia\u0026gt; @. 2 * x^2 + sin(x) #output #3-element Vector{Float64}: # 2.8414709848078967 # 8.909297426825681 # 18.14112000805987 주의 #자세한 이유는 모르나 인덱스를 1부터 시작하는걸로 보인다 #인텍스를 0으로 해서 첫번째 요소를 읽을라고 하면 오류가 발생한다. julia\u0026gt; x[0] #output #ERROR: BoundsError: attempt to access 5-element Vector{Int64} at index [0] #Stacktrace: # [1] getindex(A::Vector{Int64}, i1::Int64) # @ Base ./array.jl:801 # [2] top-level scope # @ REPL[38]:1 참고 매뉴얼\n","permalink":"https://devsanso.github.io/posts/julia/2-dot_operator/","summary":"julia에 dot 연산자라고, 배열안의 요소별로 각각 연산해주는것이 있다. 예시로 백터를 생성후 요소값들을 각각 하나씩 더하고 싶을때 보통은 for문등 방법을 사용하는게 보통이다.\njulia\u0026gt; x = [1,2,3,4,5] #output #5-element Vector{Int64}: # 1 # 2 # 3 # 4 # 5 julia\u0026gt; i = 1 julia\u0026gt; while i \u0026lt;= 5 x[i] = x[i]+2 global i += 1 end julia\u0026gt; x #output #5-element Vector{Int64}: # 3 # 4 # 5 # 6 # 7 허나 julia에서는 dot 연산자를 사용해 한줄코드로 간단하게 사용할수 있다.","title":"julia-'dot 연산자'"},{"content":"julia 공식 매뉴얼에서 변수 관련 문서를 보고 코드를 작성하면서 몇가지 특징을 알게 되었다.\n첫째로 요즘 언어들도 갖고있는 특성이지만 유니코드를 지원하여, 한글로 변수명이 가능하다는것과 심지어 특수기호로도 변수명이 되는걸 알수있다. 그렇다고 해서 한글 또는 특수기호로 변수명을 작성해서 사용하는건 비추천한다, 왜냐하면 julia는 이름 규칙이 따로 존재하기 때문이다.\njulia 명명 규칙 (발번역 주의)  변수명은 소문자로 한다 #example name = \u0026quot;Sunken Ahn\u0026quot;  단구 구분은 언더바(_)로 구분, 단 이름이 읽기 어려운게 아니면 사용은 자세 #example my_name = \u0026quot;Sunken Ahn\u0026quot;  모듈,타입은 단어 시작을 대문자로, 단어구분도 단어 첫글자를 대문자로 하여 구분 #example struct Foo bar baz end foo = Foo(1,2)  함수, 매코르는 언더바(_)없이 소문자 #example function f(x,y) x + y end  인수로 쓰는 함수(\u0026ldquo;mutating\u0026rdquo; or \u0026ldquo;in-place\u0026rdquo; functions)는 이름이 !로 끝나야 한다 #example function first_element_change_one!(v::Vector{Int64}) v[0] = 1 end   참고 매뉴얼 : variables\n","permalink":"https://devsanso.github.io/posts/julia/1-variables/","summary":"julia 공식 매뉴얼에서 변수 관련 문서를 보고 코드를 작성하면서 몇가지 특징을 알게 되었다.\n첫째로 요즘 언어들도 갖고있는 특성이지만 유니코드를 지원하여, 한글로 변수명이 가능하다는것과 심지어 특수기호로도 변수명이 되는걸 알수있다. 그렇다고 해서 한글 또는 특수기호로 변수명을 작성해서 사용하는건 비추천한다, 왜냐하면 julia는 이름 규칙이 따로 존재하기 때문이다.\njulia 명명 규칙 (발번역 주의)  변수명은 소문자로 한다 #example name = \u0026quot;Sunken Ahn\u0026quot;  단구 구분은 언더바(_)로 구분, 단 이름이 읽기 어려운게 아니면 사용은 자세 #example my_name = \u0026quot;Sunken Ahn\u0026quot;  모듈,타입은 단어 시작을 대문자로, 단어구분도 단어 첫글자를 대문자로 하여 구분 #example struct Foo bar baz end foo = Foo(1,2)  함수, 매코르는 언더바(_)없이 소문자 #example function f(x,y) x + y end  인수로 쓰는 함수(\u0026ldquo;mutating\u0026rdquo; or \u0026ldquo;in-place\u0026rdquo; functions)는 이름이 !","title":"julia-'이름 규칙'"},{"content":"최근들어 알고리즘, 영어, 수치 해석, 정보 처리 기사 공부들이 하기 힘들어서 구글링을 하며 시간을 보내던중, 스택오버플로우 2020 survey에서 개발하고 있고, 또는 개발하고 싶은 언어 상위권을 보던도중 julia라는 새로보는 언어가 있는걸 알게되고, 요즘 공부도 별로 안되니 취미로써(?) 해당 언어를 배우기로 결정하였다.\njulia 언어 해당 언어에 대해 알아본 결과 수치해석에 사용하는 프로그래밍 언어로 보인다. 또한 공식 사이트에서 해당 언어의 장점이 설명되있는데 부족한 영어실력으로 발변역을 해본결과..  Fast : 높은 성능에 맞쳐 디자인 하였으며, LLVM를 통해 효과적으로 멀티 플랫품에서 네이티브 코드로 컴파일 하였습니다. Dynamic : 스크립트 언어처럼 동적타입 언어이다. General : 비동기 I/O,메타 프로그래밍, 디버깅등을 제공한다.  등 다른 장점들을 구루 갖춘 언어인걸 알수있다.\n실행 환경 julia를 자습하기위해 설치를 해야하겠지만, 아직 기초만 배울 생각이고 계속 사용할지는 의문이라, 사용후 제거하기 편하고, 또한 설치가 편한(?) host(윈도우)가 아닌 docker로 리눅스 이미지 환경을 구축후 해당 환경에 설치하여 사용하기로 마음 먹었다. 실행환경 : docker 이미지 : 페도라 34 앞으로 해당 언어를 자습하다가, 뭔가 새롭게 느껴지는게 있으면 복습 및 저장용으로 블로그에 글을 올릴 생각이다.\n참고  stackoverflow 2020 developer survery julia offical website  ","permalink":"https://devsanso.github.io/posts/julia/0-intro/","summary":"최근들어 알고리즘, 영어, 수치 해석, 정보 처리 기사 공부들이 하기 힘들어서 구글링을 하며 시간을 보내던중, 스택오버플로우 2020 survey에서 개발하고 있고, 또는 개발하고 싶은 언어 상위권을 보던도중 julia라는 새로보는 언어가 있는걸 알게되고, 요즘 공부도 별로 안되니 취미로써(?) 해당 언어를 배우기로 결정하였다.\njulia 언어 해당 언어에 대해 알아본 결과 수치해석에 사용하는 프로그래밍 언어로 보인다. 또한 공식 사이트에서 해당 언어의 장점이 설명되있는데 부족한 영어실력으로 발변역을 해본결과..  Fast : 높은 성능에 맞쳐 디자인 하였으며, LLVM를 통해 효과적으로 멀티 플랫품에서 네이티브 코드로 컴파일 하였습니다.","title":"julia-'julia 이란?'"},{"content":"여가시간에 프로그래밍 정보를 얻어보고자 stackoverflow에서 상당히 좋은글을 보게 되었다.\n보통 코딩을 할때 \u0026ldquo;n개의 정수배열에서 y 보다 작거나 같은 Xn을 서로 합하여라\u0026rdquo; 라는 문제가 있을경우 보통 이렇게 코드를 작성하게 된다.\n//cpp 예시코드 for(int i;i\u0026lt;=array_size;i++) { int x = array[i]; if(x \u0026lt;= y) { sum += x; } } 이렇게 해당 소스코드를 작성할것이다.\n해당 소스코드는 1개의 if,한개의 비교연산자를 이용하여 x가 y보다 작거나 같으면, sum 변수에 더한다 라는 간단한 기능이 구현되어있다,그럼 여기서 어떻게 해야 성능 최적화가 되는건가?그것에 대한 답은 바로 비트연산에 있다.\n※비트연산이란? 비트 연산(bitwise operation)은 한 개 혹은 두 개의 이진수에 대해 비트 단위로 적용되는 연산이다. 일단 해답 코드를 이해하기 위해 사전정보로써 다음과 같은정보를 알고 있어야한다.  (x \u0026lt; y)에서 x-y를 하면 값은 음수다. 32비트 정수에서 음수값을 right shift로 31번 쉬프트하면 32비트들이 다 1로 바낀다. 32비트 정수에서 양수값을 right shift로 31번 쉬프트하면 32비트들이 다 0으로 바낀다. not 비트연산자를 사용하면 비트값이 반전된다 and 비트연산자는 두개의 비트값이 1일때, 결과값이 1이다.  다 해당 정보들을 외워놨으면 다음 코드가 이해할수 있을거다.\n//cpp 예시코드 { int tmp = (y-x) \u0026gt;\u0026gt; 31; /* 만약 tmp의 비트값이 전부 1이면 not연산자로 인해 0로 전부 바끼며, 0으로 and연산 하면 결과값이 0임으로 결국 sum에 0을 더한다. 즉 아무것도 더하기 않은것과 동일한 결과가 나온다. */ sum += ~tmp \u0026amp; x; } 해당 코드는 if문도 없고,비교연산자가 없지 작동이 가능하지만, 그것만으로 성능이 더 좋아질수 있을까라고 생각할것이다. 그래서 다음같은 조건으로 테스트를 해보았다.\n테스트 기기 기기이름 : 라즈베리파이4 모델 B CPU : 1.5GHz ARM Cortex-A72 MP4 RAM : 8GB LPDDR4 프로그램 조건  10000000개의 정수배열 배열의 각 요소값은 랜덤 1562값보다 작을경우 더하여, 출력  if문을 사용한 코드 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;time.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; const int count = 10000000; const int cut = 1562; int main() { srand(time(NULL)); clock_t s,l; int i = 0; int sum = 0; int *datas = (int*)malloc(sizeof(int)*count); for(;i\u0026lt;count;i++) { datas[i] = rand(); } i=0; s = clock(); //-----------테스트 코드 -------------- do { i++; if(datas[i] \u0026lt;= cut) sum += datas[i]; }while(i\u0026lt;count); //------------------------------------- l = clock(); printf(\u0026quot;time : %0.3lf(sec) \u0026quot;, (double)(l-s)/CLOCKS_PER_SEC); printf(\u0026quot;sum : %d\\n\u0026quot;,sum); return 0; } 결과 비트연산을 사용한 코드 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;time.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; const int count = 10000000; const int cut = 1562; int main() { srand(time(NULL)); clock_t s,l; int i = 0; int sum = 0; int *datas = (int*)malloc(sizeof(int)*count); int temp=0; for(;i\u0026lt;count;i++) { datas[i] = rand(); } i=0; s = clock(); //-------------- 테스트 코드 -------------------- do { i++; /* / same / if(datas[i] \u0026lt; cut) / sum += datas[i]; */ temp = (cut - datas[i]) \u0026gt;\u0026gt; 31; sum += ~temp \u0026amp; datas[i]; }while(i\u0026lt;count); //----------------------------------------------- l = clock(); printf(\u0026quot;time : %0.3lf(sec) \u0026quot;, (double)(l-s)/CLOCKS_PER_SEC); printf(\u0026quot;sum : %d\\n\u0026quot;,sum); return 0; } 결과 결론 테스트 결과 대략 5배정도 차이나는 놀라운 성능 최적화를 보여주였다. 이렇게 비트 연산을 사용하여 최적화한 글을 적어보면서, 프로그램 최적화는 끝은 없다고 생각하게 되었다. 이렇게 코드를 최적화하는 방법을 찾아보며, 포스트글을 적으면서 공부하는것도 나쁘지 않다고 생각하며 해당글은 여기서 마치겠습니다.\n참고 비트연산이란? : 위키백과\n라즈베리파이4 모델 b 사양 : 공식사이트\n해당 게시글(정확한 주제는 분기예측이다) : stack overflow\n","permalink":"https://devsanso.github.io/posts/optimizing_the_if_less_operator/","summary":"여가시간에 프로그래밍 정보를 얻어보고자 stackoverflow에서 상당히 좋은글을 보게 되었다.\n보통 코딩을 할때 \u0026ldquo;n개의 정수배열에서 y 보다 작거나 같은 Xn을 서로 합하여라\u0026rdquo; 라는 문제가 있을경우 보통 이렇게 코드를 작성하게 된다.\n//cpp 예시코드 for(int i;i\u0026lt;=array_size;i++) { int x = array[i]; if(x \u0026lt;= y) { sum += x; } } 이렇게 해당 소스코드를 작성할것이다.\n해당 소스코드는 1개의 if,한개의 비교연산자를 이용하여 x가 y보다 작거나 같으면, sum 변수에 더한다 라는 간단한 기능이 구현되어있다,그럼 여기서 어떻게 해야 성능 최적화가 되는건가?","title":"비교연산자가 포함된 if문을 비트연산으로 변화"},{"content":"","permalink":"https://devsanso.github.io/about/","summary":"","title":""}]