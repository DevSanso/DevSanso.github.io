[{"content":"러스트로 코딩하던 도중에 트레이드를 리턴해야하는 함수를 만들어야 하는 상황이 있었다. 그래서 go언어를 코딩하는것과 마찬가지로 리턴타입을 트레이드(go언어에선 인터페이스)로 하여 리턴 하는 함수를 작성후 컴파일 해본적이 있었는데 그때의 일을 적어볼려고 한다.\n//go 코드 예시 package main import \u0026#34;fmt\u0026#34; type Hi interface { hi() } type String struct { s string } func new_hi(s string) Hi { return \u0026amp;String{s} } func (s *String)hi() { fmt.Println(\u0026#34;hi : \u0026#34;s.s) } func main() { var str = \u0026#34;sunken ahn\u0026#34; new_hi(str).hi() } 이런한 기능을 하는 프로그램을 작성한다고 할때, 이것을 러스트로 재작성할려고 한다.\n그래서 내 생각대로 러스트 코드를 작성하게 되었다.\n//rust 코드 예시 trait Hi { fn hi(\u0026amp;self); } impl Hi for String { fn hi(\u0026amp;self) { println!(\u0026#34;hi : {}\u0026#34;,self); } } fn new_hi(val : String) -\u0026gt; Hi { return val; } fn main() { let name = String::from(\u0026#34;sunken ahn\u0026#34;); new_hi(name).hi(); } 이렇게 작성하고 컴파일 하니 에러메세지가 나타났다. 그래서 처음에는 이게 왜? 였다. 해당 에러가 리턴 타입 지정에서 에러가 나왓는데 다른언어들은 원하는 타입을 리턴하고 싶으면 함수에 리턴 타입을 지정하는데 말이다.\n그리고 찾아보니, rust의 컴파일 방식 때문인걸 알게 되었다. 러스트는 메모리 안전성을 위해 다른언어들과 다르게 컴파일 단계에서 메모리 관리하고 안전성을 추척한다. 그렇기에 메모리 관리를 위해 변수의 메모리 크기등을 컴파일러가 알아야 하는데, 트레이드는 이른바 일종의 여러 메소드의 묶음박스일뿐, 그 자체가 타입이 아니다. 그렇기에 변수의 메모리 크기의 정보가 없기에, 컴파일러는 해당 함수의 리턴값이 어느정도의 크기인지 알수없기에 컴파일 에러를 보내는것이다.\n그렇기에 다른방식으로 값을 리턴시키면 된다. 첫번째로 제너릭으로 함수 인수값(Hi를 구현한 String)을 받은후, 해당 인수타입으로 내보내는 방법. 두번째로 박스라는 러스트의 힙할당 구조체를 사용하여 리턴하는 방법. 그리고 내가 알고 있는 마지막 방법으로 impl trait를 리턴 타입으로 적어서 쓰는 방법이다. 참고 Traits: Defining Shared Behavior\n","permalink":"https://devsanso.github.io/posts/rust/how_return_trait/","summary":"러스트로 코딩하던 도중에 트레이드를 리턴해야하는 함수를 만들어야 하는 상황이 있었다. 그래서 go언어를 코딩하는것과 마찬가지로 리턴타입을 트레이드(go언어에선 인터페이스)로 하여 리턴 하는 함수를 작성후 컴파일 해본적이 있었는데 그때의 일을 적어볼려고 한다.\n//go 코드 예시 package main import \u0026#34;fmt\u0026#34; type Hi interface { hi() } type String struct { s string } func new_hi(s string) Hi { return \u0026amp;String{s} } func (s *String)hi() { fmt.Println(\u0026#34;hi : \u0026#34;s.s) } func main() { var str = \u0026#34;sunken ahn\u0026#34; new_hi(str).","title":"trait를 리턴하는 방법"},{"content":"프로그래밍 하는 도중 파일을 입출력 코드를 작성하는 상황이 있었는데, 여기서 \u0026ldquo;파일 입출력을 싱글 스레드 그리고 멀티 스레드중 어느것이 나을까?\u0026ldquo;라고 궁금중이 생겨서, 따로 코드를 작성하고 테스트했던것을 적어볼려고 한다.\n우선 나는 어느것이 성능이 좋을지 생각하면서 어떤 프로그램 요구서를 생각하고, 그것에 따라서 작성해보았다.\n프로그램 계획 요구 : 랜덤 해쉬값을 생성후, 해당값을 파일이름 그리고 파일내용으로 작성하여 특정폴더에 저장한다.  프로그램은 싱글,멀티스레드 선택값,폴더경로 그리고 파일 생성 갯수값을 인수로 입력받는다 해쉬값을 랜덤으로 생성한다 해당값으로 파일명으로 해서 생성후, 해당 파일에 해당값을 저장 이 행동을 생성 갯수값만큼 반복한다 반복이 완료후의 시간을 측정하고, 출력한다 프로그램 종료  그리고 해당 요구서를 토대로 코틀린으로 작성해보았다.\n//main.kt //메인 함수 import java.lang.Exception import kotlin.system.measureTimeMillis fun main(args: Array\u0026lt;String\u0026gt;) { val c = args.first().toInt() // 1 : 멀티스레드,2: 싱글스레드 val root = args[1] // 폴더 경로 val count = args[2].toInt() // 파일 생성 갯수 val fIO : IoTest = when(c) { 1 -\u0026gt; AsyncFileIO(count,root,4)// 스레드는 4개 생성후 사용 2 -\u0026gt; NonFileIO(count,root) else -\u0026gt; throw Exception(\u0026quot;not 1 and 2\u0026quot;) } val time = measureTimeMillis { fIO.run() } println(\u0026quot;time : ${time}(ms)\u0026quot;) } //IoTest.kt //추상클래스 abstract class IoTest constructor(protected val maxCount : Int,protected val root : String) { abstract fun run() } //NonFileIO.kt //싱글 스레드 작동 객체 import kotlin.io.* import java.io.File import java.nio.charset.Charset import java.util.UUID import java.nio.file.Paths class NonFileIO(maxCount: Int, root: String) : IoTest(maxCount, root) { override fun run() { var i = 0; var random_uuid = UUID.randomUUID().toString() while(i \u0026lt; maxCount) { var file = File(Paths.get(root,random_uuid).toString()) file.createNewFile() file.writeText(random_uuid, Charset.defaultCharset()) random_uuid = UUID.randomUUID().toString() i++ } } } //AsyncFileIO.kt //멀티스레드 작성 객체 import kotlinx.coroutines.* import kotlinx.coroutines.channels.Channel import java.io.File import java.nio.charset.Charset import java.nio.file.Paths import java.util.* class AsyncFileIO( maxCount: Int, root: String,private val tCount : Int) : IoTest(maxCount, root) { private suspend fun createWorker (channel : Channel\u0026lt;String\u0026gt;) { for(i in 1..tCount) { //해당 코드를 사용하면 자바내부에 스레드가 생성된다. CoroutineScope(Dispatchers.IO).launch { while(!channel.isClosedForSend) { if(channel.isEmpty)continue val msg = channel.receive() var file = File(Paths.get(root,msg).toString()) file.createNewFile() file.writeText(msg, Charset.defaultCharset()) } } } } override fun run() : Unit = runBlocking { val channel = Channel\u0026lt;String\u0026gt;() val job = async { createWorker(channel) } for(i in 1..maxCount) { var random_uuid = UUID.randomUUID().toString() channel.send(random_uuid) } channel.close() job.await() } } 간단 설명 이미지 이것을 토대로 10000개의 파일을 생성하는 테스트를 해본결과\u0026hellip;\n결과창    방식 시간표     싱글스레드 68.953s   멀티스레드 46.261s    이렇게 꽤 차이 나는 결과를 알게되었다.\n","permalink":"https://devsanso.github.io/posts/thread_file_io_performance/","summary":"프로그래밍 하는 도중 파일을 입출력 코드를 작성하는 상황이 있었는데, 여기서 \u0026ldquo;파일 입출력을 싱글 스레드 그리고 멀티 스레드중 어느것이 나을까?\u0026ldquo;라고 궁금중이 생겨서, 따로 코드를 작성하고 테스트했던것을 적어볼려고 한다.\n우선 나는 어느것이 성능이 좋을지 생각하면서 어떤 프로그램 요구서를 생각하고, 그것에 따라서 작성해보았다.\n프로그램 계획 요구 : 랜덤 해쉬값을 생성후, 해당값을 파일이름 그리고 파일내용으로 작성하여 특정폴더에 저장한다.  프로그램은 싱글,멀티스레드 선택값,폴더경로 그리고 파일 생성 갯수값을 인수로 입력받는다 해쉬값을 랜덤으로 생성한다 해당값으로 파일명으로 해서 생성후, 해당 파일에 해당값을 저장 이 행동을 생성 갯수값만큼 반복한다 반복이 완료후의 시간을 측정하고, 출력한다 프로그램 종료  그리고 해당 요구서를 토대로 코틀린으로 작성해보았다.","title":"싱글,멀티 스레드 파일 입출력 성능 "},{"content":"자바스크립트를 공부하다보면 비동기 함수 사용이라고 setTimeout , Promise 그리고 async과 await를 배우게 된다. 허나 이러한 사용법이 있다고 하고, 어떤 상황에 어떻게 써야하는지는 자세히 모르는경우 가 많았고, 그리고 이번에 이 궁금점을 풀기위해 코드를 작성하다가 알게된 내용을 적어볼려고한다.\n보통 자바스크립트는 싱글 스레드이기 때문에 비동기api를 이용하여 멀티스레딩을 한다고 이야기를 한다. 결국 비동기로 병렬처리를 하는것처럼 보여도 결국 싱글스레드에서 모든일을 한다는것이다, 그럼 만약 여러 비동기 함수안에 처리시간이 많은 루프가 있으면 어떻게 될까?\n해당 궁금점을 알기위해 코드를 작성하기로 마음먹고, 다음과 같은 규칙과 목표를 세웠다.\n프로그램 규칙  웹페이지를 전송주고, 특정 데이터를 보내주는 서버를 만든다, 그리고 데이터는 0~1000사이의 정수이며, 데이터의 값은 랜덤이다. 웹사이트는 처음 로딩시 4개의 객체가 있고,각 객체만 무작위로 하나의 정수를 할당받는다. 각 하나의 객체는, 각자의 정수값이 서버로부터 받는 정수데이터값하고 동일할때까지 계속 서버에 데이터값을 요청한다. 만약 데이터가 동일하지 않으면 화면에 실패 횟수를 보여준다 하나의 객체가, 서버로부터 온 데이터랑 동일하면 활동을 멈춘다  설명이 부족해 보일수도 있기에, 일단 코드예시도 올리기로 결정했다.\n//server source code package main import ( \u0026#34;net/http\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;math/rand\u0026#34; ) func ramdonIntHandler(w http.ResponseWriter,r *http.Request) { var s = rand.Int() %1001 var conv = strconv.Itoa(s) w.WriteHeader(200) w.Write([]byte(conv)) } func main() { //www : 웹페이지가 저장되있는 폴더 \tfs := http.FileServer(http.FS(os.DirFS(\u0026#34;.\\\\www\u0026#34;))) http.Handle(\u0026#34;/\u0026#34;, fs) http.HandleFunc(\u0026#34;/random\u0026#34;,ramdonIntHandler) log.Println(\u0026#34;Listening on :3000...\u0026#34;) err := http.ListenAndServe(\u0026#34;:3000\u0026#34;,nil) if err != nil {log.Fatal(err)} } \u0026lt;!-- 웹페이지 html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;match number\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;section id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;switchBox box1\u0026#34;\u0026gt; \u0026lt;span\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;switchBox box2\u0026#34;\u0026gt; \u0026lt;span\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;switchBox box3\u0026#34;\u0026gt; \u0026lt;span\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;switchBox box4\u0026#34;\u0026gt; \u0026lt;span\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- 비동기로 서버로 요청하는 라이브러리--\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;./assets/js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;button onclick=\u0026#34;main();\u0026#34;\u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; const Box = function(className) { this.switch = false; this.num = parseInt((Math.random() * 1000)); this.className = className this.update = (data) =\u0026gt; { this.switch = this.num == data ? true : false; } let doc =document.querySelector(\u0026#34;.\u0026#34;+className + \u0026#34; \u0026gt; span\u0026#34;); return { //Promise.then을 이용한 함수  loop :async () =\u0026gt; { while(!this.switch) { axios({ method: \u0026#39;get\u0026#39;, url: \u0026#34;/random\u0026#34; }).then((value)=\u0026gt; { let d = parseInt(value.data); this.update(d); doc.textContent = parseInt(doc.textContent) + 1 }); } console.log(\u0026#34;done \u0026#34; + this.className); }, //setTimeout를 이용한 루프  loopSetTimeout : () =\u0026gt; { let body = () =\u0026gt; { axios({ method: \u0026#39;get\u0026#39;, url: \u0026#34;/random\u0026#34; }).then((value)=\u0026gt; { let d = parseInt(value.data); this.update(d); doc.textContent = parseInt(doc.textContent) + 1 if(!this.switch)setTimeout(body,10); }); } setTimeout(body,10); }, //await를 이용한 함수  loopAwait :async () =\u0026gt; { while(!this.switch) { let res = await axios({ method: \u0026#39;get\u0026#39;, url: \u0026#34;/random\u0026#34; }); let d = parseInt(res.data); this.update(d); doc.textContent = parseInt(doc.textContent) + 1; } console.log(\u0026#34;done \u0026#34; + this.className); }, getNum : () =\u0026gt; this.num } } function AllocBox(ele) { let element = new Box(ele); //element.loop();  //element.loopSetTimeout();  //element.loopAwait();  console.log(ele + \u0026#34; Box Number = \u0026#34; + element.getNum()); } const main = () =\u0026gt; { AllocBox(\u0026#34;box1\u0026#34;); AllocBox(\u0026#34;box2\u0026#34;); AllocBox(\u0026#34;box3\u0026#34;); AllocBox(\u0026#34;box4\u0026#34;); } 자바스크립트에는 각자 어떻게 작동되는지 알기위해 각 3개의 함수를 작성하고 테스트를 해본 결과 뜻밖에 결과가 나왔다.\n결론부터 말씀드리면, setTimeout과 await는 정상적으로 작동되는걸 확인되었다. 해당 결과는 await의 결과지만, setTimeout도 비슷하게 작동하였다. 그 대신 promise.then쪽은 예상과 다르게 작동했는데, 결과값이 다른것도 아닌 아예 웹페이지 자체가 작동을 멈추게 되었다. 새로고침, 페이지 종료창을 마우스로 클리해도 응답 자체가 되지 않았다. 우선 await부터 살펴보자, 사실 본래 await는 저렇게 객체들이 동시에 서버에 요청하기에 한꺼번에 숫자 횟수가 바끼는걸 볼수 있다. 사실 이건 본인이 예상했던 결과가 아니다.\n그 이유를 나열하자면\n 비동기로 처리해도 결국 하나의 스레드는 하나의 함수만 처리할수 있다. 그리고 실행중인 함수가 끝나야 이벤트큐에 들어있는 다음 비동기 함수를 실행할수 있다. 만약 처리하는 함수가 오래 걸리는 루프가 있을시, 해당 루프를 탈출하기 전까지 함수는 종료되지 않는다. 그렇기에 결국 한객체만 처리할수밖에 없는 상황이 된다.  위 조건에 맞는것이 바로 promise.then를 사용한 방법이다. 실제 함수 중간에 console.log 함수를 작성하여 테스트한 결과, 한 객체의 promise만이 수없이 작동되게 된다. 그렇게 이벤트 큐에 끊임없이 쌓이게되니 브라우저가 결국 먹통되었다고 추측하고 있다. 허나 그렇게 되지 않았고, 그 이유를 찾아본 결과, async함수에서 await블록으로 진입시, 해당 함수는 await블록에서 일시 정지되고, 다음 async함수가 실행되게 된다, 그후 일시정지된 함수가 다시 돌아오면 await가 처리 완료되면 async함수를 마저 처리하고, 만약 아직 완료가 안되면 또 일시 정지후 다음 함수가 실행된다는거다.\n정확한 내용을 알고싶으면 해당 사이트를 참고하면 좋을것이다.  mdn web docs stackoverflow question  ","permalink":"https://devsanso.github.io/posts/javascript/difference_between_await_and_then/","summary":"자바스크립트를 공부하다보면 비동기 함수 사용이라고 setTimeout , Promise 그리고 async과 await를 배우게 된다. 허나 이러한 사용법이 있다고 하고, 어떤 상황에 어떻게 써야하는지는 자세히 모르는경우 가 많았고, 그리고 이번에 이 궁금점을 풀기위해 코드를 작성하다가 알게된 내용을 적어볼려고한다.\n보통 자바스크립트는 싱글 스레드이기 때문에 비동기api를 이용하여 멀티스레딩을 한다고 이야기를 한다. 결국 비동기로 병렬처리를 하는것처럼 보여도 결국 싱글스레드에서 모든일을 한다는것이다, 그럼 만약 여러 비동기 함수안에 처리시간이 많은 루프가 있으면 어떻게 될까?\n해당 궁금점을 알기위해 코드를 작성하기로 마음먹고, 다음과 같은 규칙과 목표를 세웠다.","title":"await와 then의 작동 차이"},{"content":"julia에 dot 연산자라고, 배열안의 요소별로 각각 연산해주는것이 있다. 예시로 백터를 생성후 요소값들을 각각 하나씩 더하고 싶을때 보통은 for문등 방법을 사용하는게 보통이다.\njulia\u0026gt; x = [1,2,3,4,5] #output #5-element Vector{Int64}: # 1 # 2 # 3 # 4 # 5 julia\u0026gt; i = 1 julia\u0026gt; while i \u0026lt;= 5 x[i] = x[i]+2 global i += 1 end julia\u0026gt; x #output #5-element Vector{Int64}: # 3 # 4 # 5 # 6 # 7 허나 julia에서는 dot 연산자를 사용해 한줄코드로 간단하게 사용할수 있다.\njulia\u0026gt; x .+ 2 #output #5-element Vector{Int64}: # 3 # 4 # 5 # 6 # 7 또한 julia에서는 \u0026ldquo;@.\u0026ldquo;라는 매크로가 존재하는데, 계산식에 많은 dot(.)이 있을경우 표현식의 길이가 길어질수 있는데, 해당 매크로를 사용하면 dot를 각 연산자마다 사용할 필요가 없어져서, 표현식이 더 간결해질수 있다.\njulia\u0026gt; x = [1,2,3] #output #3-element Vector{Int64}: # 1 # 2 # 3 julia\u0026gt; 2 .* x.^2 .+ sin.(x) #output #3-element Vector{Float64}: # 2.8414709848078967 # 8.909297426825681 # 18.14112000805987 julia\u0026gt; @. 2 * x^2 + sin(x) #output #3-element Vector{Float64}: # 2.8414709848078967 # 8.909297426825681 # 18.14112000805987 주의 #자세한 이유는 모르나 인덱스를 1부터 시작하는걸로 보인다 #인텍스를 0으로 해서 첫번째 요소를 읽을라고 하면 오류가 발생한다. julia\u0026gt; x[0] #output #ERROR: BoundsError: attempt to access 5-element Vector{Int64} at index [0] #Stacktrace: # [1] getindex(A::Vector{Int64}, i1::Int64) # @ Base ./array.jl:801 # [2] top-level scope # @ REPL[38]:1 참고 매뉴얼\n","permalink":"https://devsanso.github.io/posts/julia/2-dot_operator/","summary":"julia에 dot 연산자라고, 배열안의 요소별로 각각 연산해주는것이 있다. 예시로 백터를 생성후 요소값들을 각각 하나씩 더하고 싶을때 보통은 for문등 방법을 사용하는게 보통이다.\njulia\u0026gt; x = [1,2,3,4,5] #output #5-element Vector{Int64}: # 1 # 2 # 3 # 4 # 5 julia\u0026gt; i = 1 julia\u0026gt; while i \u0026lt;= 5 x[i] = x[i]+2 global i += 1 end julia\u0026gt; x #output #5-element Vector{Int64}: # 3 # 4 # 5 # 6 # 7 허나 julia에서는 dot 연산자를 사용해 한줄코드로 간단하게 사용할수 있다.","title":"julia-'dot 연산자'"},{"content":"julia 공식 매뉴얼에서 변수 관련 문서를 보고 코드를 작성하면서 몇가지 특징을 알게 되었다.\n첫째로 요즘 언어들도 갖고있는 특성이지만 유니코드를 지원하여, 한글로 변수명이 가능하다는것과 심지어 특수기호로도 변수명이 되는걸 알수있다. 그렇다고 해서 한글 또는 특수기호로 변수명을 작성해서 사용하는건 비추천한다, 왜냐하면 julia는 이름 규칙이 따로 존재하기 때문이다.\njulia 명명 규칙 (발번역 주의)  변수명은 소문자로 한다 #example name = \u0026quot;Sunken Ahn\u0026quot;  단구 구분은 언더바(_)로 구분, 단 이름이 읽기 어려운게 아니면 사용은 자세 #example my_name = \u0026quot;Sunken Ahn\u0026quot;  모듈,타입은 단어 시작을 대문자로, 단어구분도 단어 첫글자를 대문자로 하여 구분 #example struct Foo bar baz end foo = Foo(1,2)  함수, 매코르는 언더바(_)없이 소문자 #example function f(x,y) x + y end  인수로 쓰는 함수(\u0026ldquo;mutating\u0026rdquo; or \u0026ldquo;in-place\u0026rdquo; functions)는 이름이 !로 끝나야 한다 #example function first_element_change_one!(v::Vector{Int64}) v[0] = 1 end   참고 매뉴얼 : variables\n","permalink":"https://devsanso.github.io/posts/julia/1-variables/","summary":"julia 공식 매뉴얼에서 변수 관련 문서를 보고 코드를 작성하면서 몇가지 특징을 알게 되었다.\n첫째로 요즘 언어들도 갖고있는 특성이지만 유니코드를 지원하여, 한글로 변수명이 가능하다는것과 심지어 특수기호로도 변수명이 되는걸 알수있다. 그렇다고 해서 한글 또는 특수기호로 변수명을 작성해서 사용하는건 비추천한다, 왜냐하면 julia는 이름 규칙이 따로 존재하기 때문이다.\njulia 명명 규칙 (발번역 주의)  변수명은 소문자로 한다 #example name = \u0026quot;Sunken Ahn\u0026quot;  단구 구분은 언더바(_)로 구분, 단 이름이 읽기 어려운게 아니면 사용은 자세 #example my_name = \u0026quot;Sunken Ahn\u0026quot;  모듈,타입은 단어 시작을 대문자로, 단어구분도 단어 첫글자를 대문자로 하여 구분 #example struct Foo bar baz end foo = Foo(1,2)  함수, 매코르는 언더바(_)없이 소문자 #example function f(x,y) x + y end  인수로 쓰는 함수(\u0026ldquo;mutating\u0026rdquo; or \u0026ldquo;in-place\u0026rdquo; functions)는 이름이 !","title":"julia-'이름 규칙'"},{"content":"최근들어 알고리즘, 영어, 수치 해석, 정보 처리 기사 공부들이 하기 힘들어서 구글링을 하며 시간을 보내던중, 스택오버플로우 2020 survey에서 개발하고 있고, 또는 개발하고 싶은 언어 상위권을 보던도중 julia라는 새로보는 언어가 있는걸 알게되고, 요즘 공부도 별로 안되니 취미로써(?) 해당 언어를 배우기로 결정하였다.\njulia 언어 해당 언어에 대해 알아본 결과 수치해석에 사용하는 프로그래밍 언어로 보인다. 또한 공식 사이트에서 해당 언어의 장점이 설명되있는데 부족한 영어실력으로 발변역을 해본결과..  Fast : 높은 성능에 맞쳐 디자인 하였으며, LLVM를 통해 효과적으로 멀티 플랫품에서 네이티브 코드로 컴파일 하였습니다. Dynamic : 스크립트 언어처럼 동적타입 언어이다. General : 비동기 I/O,메타 프로그래밍, 디버깅등을 제공한다.  등 다른 장점들을 구루 갖춘 언어인걸 알수있다.\n실행 환경 julia를 자습하기위해 설치를 해야하겠지만, 아직 기초만 배울 생각이고 계속 사용할지는 의문이라, 사용후 제거하기 편하고, 또한 설치가 편한(?) host(윈도우)가 아닌 docker로 리눅스 이미지 환경을 구축후 해당 환경에 설치하여 사용하기로 마음 먹었다. 실행환경 : docker 이미지 : 페도라 34 앞으로 해당 언어를 자습하다가, 뭔가 새롭게 느껴지는게 있으면 복습 및 저장용으로 블로그에 글을 올릴 생각이다.\n참고  stackoverflow 2020 developer survery julia offical website  ","permalink":"https://devsanso.github.io/posts/julia/0-intro/","summary":"최근들어 알고리즘, 영어, 수치 해석, 정보 처리 기사 공부들이 하기 힘들어서 구글링을 하며 시간을 보내던중, 스택오버플로우 2020 survey에서 개발하고 있고, 또는 개발하고 싶은 언어 상위권을 보던도중 julia라는 새로보는 언어가 있는걸 알게되고, 요즘 공부도 별로 안되니 취미로써(?) 해당 언어를 배우기로 결정하였다.\njulia 언어 해당 언어에 대해 알아본 결과 수치해석에 사용하는 프로그래밍 언어로 보인다. 또한 공식 사이트에서 해당 언어의 장점이 설명되있는데 부족한 영어실력으로 발변역을 해본결과..  Fast : 높은 성능에 맞쳐 디자인 하였으며, LLVM를 통해 효과적으로 멀티 플랫품에서 네이티브 코드로 컴파일 하였습니다.","title":"julia-'julia 이란?'"},{"content":"여가시간에 프로그래밍 정보를 얻어보고자 stackoverflow에서 상당히 좋은글을 보게 되었다.\n보통 코딩을 할때 \u0026ldquo;n개의 정수배열에서 y 보다 작거나 같은 Xn을 서로 합하여라\u0026rdquo; 라는 문제가 있을경우 보통 이렇게 코드를 작성하게 된다.\n//cpp 예시코드 for(int i;i\u0026lt;=array_size;i++) { int x = array[i]; if(x \u0026lt;= y) { sum += x; } } 이렇게 해당 소스코드를 작성할것이다.\n해당 소스코드는 1개의 if,한개의 비교연산자를 이용하여 x가 y보다 작거나 같으면, sum 변수에 더한다 라는 간단한 기능이 구현되어있다,그럼 여기서 어떻게 해야 성능 최적화가 되는건가?그것에 대한 답은 바로 비트연산에 있다.\n※비트연산이란? 비트 연산(bitwise operation)은 한 개 혹은 두 개의 이진수에 대해 비트 단위로 적용되는 연산이다. 일단 해답 코드를 이해하기 위해 사전정보로써 다음과 같은정보를 알고 있어야한다.  (x \u0026lt; y)에서 x-y를 하면 값은 음수다. 32비트 정수에서 음수값을 right shift로 31번 쉬프트하면 32비트들이 다 1로 바낀다. 32비트 정수에서 양수값을 right shift로 31번 쉬프트하면 32비트들이 다 0으로 바낀다. not 비트연산자를 사용하면 비트값이 반전된다 and 비트연산자는 두개의 비트값이 1일때, 결과값이 1이다.  다 해당 정보들을 외워놨으면 다음 코드가 이해할수 있을거다.\n//cpp 예시코드 { int tmp = (y-x) \u0026gt;\u0026gt; 31; /* 만약 tmp의 비트값이 전부 1이면 not연산자로 인해 0로 전부 바끼며, 0으로 and연산 하면 결과값이 0임으로 결국 sum에 0을 더한다. 즉 아무것도 더하기 않은것과 동일한 결과가 나온다. */ sum += ~tmp \u0026amp; x; } 해당 코드는 if문도 없고,비교연산자가 없지 작동이 가능하지만, 그것만으로 성능이 더 좋아질수 있을까라고 생각할것이다. 그래서 다음같은 조건으로 테스트를 해보았다.\n테스트 기기 기기이름 : 라즈베리파이4 모델 B CPU : 1.5GHz ARM Cortex-A72 MP4 RAM : 8GB LPDDR4 프로그램 조건  10000000개의 정수배열 배열의 각 요소값은 랜덤 1562값보다 작을경우 더하여, 출력  if문을 사용한 코드 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;time.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; const int count = 10000000; const int cut = 1562; int main() { srand(time(NULL)); clock_t s,l; int i = 0; int sum = 0; int *datas = (int*)malloc(sizeof(int)*count); for(;i\u0026lt;count;i++) { datas[i] = rand(); } i=0; s = clock(); //-----------테스트 코드 -------------- do { i++; if(datas[i] \u0026lt;= cut) sum += datas[i]; }while(i\u0026lt;count); //------------------------------------- l = clock(); printf(\u0026quot;time : %0.3lf(sec) \u0026quot;, (double)(l-s)/CLOCKS_PER_SEC); printf(\u0026quot;sum : %d\\n\u0026quot;,sum); return 0; } 결과 비트연산을 사용한 코드 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;time.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; const int count = 10000000; const int cut = 1562; int main() { srand(time(NULL)); clock_t s,l; int i = 0; int sum = 0; int *datas = (int*)malloc(sizeof(int)*count); int temp=0; for(;i\u0026lt;count;i++) { datas[i] = rand(); } i=0; s = clock(); //-------------- 테스트 코드 -------------------- do { i++; /* / same / if(datas[i] \u0026lt; cut) / sum += datas[i]; */ temp = (cut - datas[i]) \u0026gt;\u0026gt; 31; sum += ~temp \u0026amp; datas[i]; }while(i\u0026lt;count); //----------------------------------------------- l = clock(); printf(\u0026quot;time : %0.3lf(sec) \u0026quot;, (double)(l-s)/CLOCKS_PER_SEC); printf(\u0026quot;sum : %d\\n\u0026quot;,sum); return 0; } 결과 결론 테스트 결과 대략 5배정도 차이나는 놀라운 성능 최적화를 보여주였다. 이렇게 비트 연산을 사용하여 최적화한 글을 적어보면서, 프로그램 최적화는 끝은 없다고 생각하게 되었다. 이렇게 코드를 최적화하는 방법을 찾아보며, 포스트글을 적으면서 공부하는것도 나쁘지 않다고 생각하며 해당글은 여기서 마치겠습니다.\n참고 비트연산이란? : 위키백과\n라즈베리파이4 모델 b 사양 : 공식사이트\n해당 게시글(정확한 주제는 분기예측이다) : stack overflow\n","permalink":"https://devsanso.github.io/posts/optimizing_the_if_less_operator/","summary":"여가시간에 프로그래밍 정보를 얻어보고자 stackoverflow에서 상당히 좋은글을 보게 되었다.\n보통 코딩을 할때 \u0026ldquo;n개의 정수배열에서 y 보다 작거나 같은 Xn을 서로 합하여라\u0026rdquo; 라는 문제가 있을경우 보통 이렇게 코드를 작성하게 된다.\n//cpp 예시코드 for(int i;i\u0026lt;=array_size;i++) { int x = array[i]; if(x \u0026lt;= y) { sum += x; } } 이렇게 해당 소스코드를 작성할것이다.\n해당 소스코드는 1개의 if,한개의 비교연산자를 이용하여 x가 y보다 작거나 같으면, sum 변수에 더한다 라는 간단한 기능이 구현되어있다,그럼 여기서 어떻게 해야 성능 최적화가 되는건가?","title":"비교연산자가 포함된 if문을 비트연산으로 변화"},{"content":"","permalink":"https://devsanso.github.io/about/","summary":"","title":""}]