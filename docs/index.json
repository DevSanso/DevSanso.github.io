[{"content":"자바스크립트를 공부하다보면 비동기 함수 사용이라고 setTimeout , Promise 그리고 async과 await를 배우게 된다. 허나 이러한 사용법이 있다고 하고, 어떤 상황에 어떻게 써야하는지는 자세히 모르는경우 가 많았고, 그리고 이번에 이 궁금점을 풀기위해 코드를 작성하다가 알게된 내용을 적어볼려고한다.\n보통 자바스크립트는 싱글 스레드이기 때문에 비동기api를 이용하여 멀티스레딩을 한다고 이야기를 한다. 결국 비동기로 병렬처리를 하는것처럼 보여도 결국 싱글스레드에서 모든일을 한다는것이다, 그럼 만약 여러 비동기 함수안에 처리시간이 많은 루프가 있으면 어떻게 될까?\n해당 궁금점을 알기위해 코드를 작성하기로 마음먹고, 다음과 같은 규칙과 목표를 세웠다.\n프로그램 규칙  웹페이지를 전송주고, 특정 데이터를 보내주는 서버를 만든다, 그리고 데이터는 0~1000사이의 정수이며, 데이터의 값은 랜덤이다. 웹사이트는 처음 로딩시 4개의 객체가 있고,각 객체만 무작위로 하나의 정수를 할당받는다. 각 하나의 객체는, 각자의 정수값이 서버로부터 받는 정수데이터값하고 동일할때까지 계속 서버에 데이터값을 요청한다. 만약 데이터가 동일하지 않으면 화면에 실패 횟수를 보여준다 하나의 객체가, 서버로부터 온 데이터랑 동일하면 활동을 멈춘다  설명이 부족해 보일수도 있기에, 일단 코드예시도 올리기로 결정했다.\n//server source code package main import ( \u0026#34;net/http\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;math/rand\u0026#34; ) func ramdonIntHandler(w http.ResponseWriter,r *http.Request) { var s = rand.Int() %1001 var conv = strconv.Itoa(s) w.WriteHeader(200) w.Write([]byte(conv)) } func main() { //www : 웹페이지가 저장되있는 폴더 \tfs := http.FileServer(http.FS(os.DirFS(\u0026#34;.\\\\www\u0026#34;))) http.Handle(\u0026#34;/\u0026#34;, fs) http.HandleFunc(\u0026#34;/random\u0026#34;,ramdonIntHandler) log.Println(\u0026#34;Listening on :3000...\u0026#34;) err := http.ListenAndServe(\u0026#34;:3000\u0026#34;,nil) if err != nil {log.Fatal(err)} } \u0026lt;!-- 웹페이지 html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;match number\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;section id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;switchBox box1\u0026#34;\u0026gt; \u0026lt;span\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;switchBox box2\u0026#34;\u0026gt; \u0026lt;span\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;switchBox box3\u0026#34;\u0026gt; \u0026lt;span\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;switchBox box4\u0026#34;\u0026gt; \u0026lt;span\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- 비동기로 서버로 요청하는 라이브러리--\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;./assets/js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;button onclick=\u0026#34;main();\u0026#34;\u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; const Box = function(className) { this.switch = false; this.num = parseInt((Math.random() * 1000)); this.className = className this.update = (data) =\u0026gt; { this.switch = this.num == data ? true : false; } let doc =document.querySelector(\u0026#34;.\u0026#34;+className + \u0026#34; \u0026gt; span\u0026#34;); return { //Promise.then을 이용한 함수  loop :async () =\u0026gt; { while(!this.switch) { axios({ method: \u0026#39;get\u0026#39;, url: \u0026#34;/random\u0026#34; }).then((value)=\u0026gt; { let d = parseInt(value.data); this.update(d); doc.textContent = parseInt(doc.textContent) + 1 }); } console.log(\u0026#34;done \u0026#34; + this.className); }, //setTimeout를 이용한 루프  loopSetTimeout : () =\u0026gt; { let body = () =\u0026gt; { axios({ method: \u0026#39;get\u0026#39;, url: \u0026#34;/random\u0026#34; }).then((value)=\u0026gt; { let d = parseInt(value.data); this.update(d); doc.textContent = parseInt(doc.textContent) + 1 if(!this.switch)setTimeout(body,10); }); } setTimeout(body,10); }, //await를 이용한 함수  loopAwait :async () =\u0026gt; { while(!this.switch) { let res = await axios({ method: \u0026#39;get\u0026#39;, url: \u0026#34;/random\u0026#34; }); let d = parseInt(res.data); this.update(d); doc.textContent = parseInt(doc.textContent) + 1; } console.log(\u0026#34;done \u0026#34; + this.className); }, getNum : () =\u0026gt; this.num } } function AllocBox(ele) { let element = new Box(ele); //element.loop();  //element.loopSetTimeout();  //element.loopAwait();  console.log(ele + \u0026#34; Box Number = \u0026#34; + element.getNum()); } const main = () =\u0026gt; { AllocBox(\u0026#34;box1\u0026#34;); AllocBox(\u0026#34;box2\u0026#34;); AllocBox(\u0026#34;box3\u0026#34;); AllocBox(\u0026#34;box4\u0026#34;); } 자바스크립트에는 각자 어떻게 작동되는지 알기위해 각 3개의 함수를 작성하고 테스트를 해본 결과 뜻밖에 결과가 나왔다.\n결론부터 말씀드리면, setTimeout과 await는 정상적으로 작동되는걸 확인되었다. 해당 결과는 await의 결과지만, setTimeout도 비슷하게 작동하였다. 그 대신 promise.then쪽은 예상과 다르게 작동했는데, 결과값이 다른것도 아닌 아예 웹페이지 자체가 작동을 멈추게 되었다. 새로고침, 페이지 종료창을 마우스로 클리해도 응답 자체가 되지 않았다. 우선 await부터 살펴보자, 사실 본래 await는 저렇게 객체들이 동시에 서버에 요청하기에 한꺼번에 숫자 횟수가 바끼는걸 볼수 있다. 사실 이건 본인이 예상했던 결과가 아니다.\n그 이유를 나열하자면\n 비동기로 처리해도 결국 하나의 스레드는 하나의 함수만 처리할수 있다. 그리고 실행중인 함수가 끝나야 이벤트큐에 들어있는 다음 비동기 함수를 실행할수 있다. 만약 처리하는 함수가 오래 걸리는 루프가 있을시, 해당 루프를 탈출하기 전까지 함수는 종료되지 않는다. 그렇기에 결국 한객체만 처리할수밖에 없는 상황이 된다.  위 조건에 맞는것이 바로 promise.then를 사용한 방법이다. 실제 함수 중간에 console.log 함수를 작성하여 테스트한 결과, 한 객체의 promise만이 수없이 작동되게 된다. 그렇게 이벤트 큐에 끊임없이 쌓이게되니 브라우저가 결국 먹통되었다고 추측하고 있다. 허나 그렇게 되지 않았고, 그 이유를 찾아본 결과, async함수에서 await블록으로 진입시, 해당 함수는 await블록에서 일시 정지되고, 다음 async함수가 실행되게 된다, 그후 일시정지된 함수가 다시 돌아오면 await가 처리 완료되면 async함수를 마저 처리하고, 만약 아직 완료가 안되면 또 일시 정지후 다음 함수가 실행된다는거다.\n정확한 내용을 알고싶으면 해당 사이트를 참고하면 좋을것이다.  mdn web docs stackoverflow question  ","permalink":"http://example.org/posts/javascript/difference_between_await_and_then/","summary":"자바스크립트를 공부하다보면 비동기 함수 사용이라고 setTimeout , Promise 그리고 async과 await를 배우게 된다. 허나 이러한 사용법이 있다고 하고, 어떤 상황에 어떻게 써야하는지는 자세히 모르는경우 가 많았고, 그리고 이번에 이 궁금점을 풀기위해 코드를 작성하다가 알게된 내용을 적어볼려고한다.\n보통 자바스크립트는 싱글 스레드이기 때문에 비동기api를 이용하여 멀티스레딩을 한다고 이야기를 한다. 결국 비동기로 병렬처리를 하는것처럼 보여도 결국 싱글스레드에서 모든일을 한다는것이다, 그럼 만약 여러 비동기 함수안에 처리시간이 많은 루프가 있으면 어떻게 될까?\n해당 궁금점을 알기위해 코드를 작성하기로 마음먹고, 다음과 같은 규칙과 목표를 세웠다.","title":"await와 then의 작동 차이"},{"content":"julia에 dot 연산자라고, 배열안의 요소별로 각각 연산해주는것이 있다. 예시로 백터를 생성후 요소값들을 각각 하나씩 더하고 싶을때 보통은 for문등 방법을 사용하는게 보통이다.\njulia\u0026gt; x = [1,2,3,4,5] #output #5-element Vector{Int64}: # 1 # 2 # 3 # 4 # 5 julia\u0026gt; i = 1 julia\u0026gt; while i \u0026lt;= 5 x[i] = x[i]+2 global i += 1 end julia\u0026gt; x #output #5-element Vector{Int64}: # 3 # 4 # 5 # 6 # 7 허나 julia에서는 dot 연산자를 사용해 한줄코드로 간단하게 사용할수 있다.\njulia\u0026gt; x .+ 2 #output #5-element Vector{Int64}: # 3 # 4 # 5 # 6 # 7 또한 julia에서는 \u0026ldquo;@.\u0026ldquo;라는 매크로가 존재하는데, 계산식에 많은 dot(.)이 있을경우 표현식의 길이가 길어질수 있는데, 해당 매크로를 사용하면 dot를 각 연산자마다 사용할 필요가 없어져서, 표현식이 더 간결해질수 있다.\njulia\u0026gt; x = [1,2,3] #output #3-element Vector{Int64}: # 1 # 2 # 3 julia\u0026gt; 2 .* x.^2 .+ sin.(x) #output #3-element Vector{Float64}: # 2.8414709848078967 # 8.909297426825681 # 18.14112000805987 julia\u0026gt; @. 2 * x^2 + sin(x) #output #3-element Vector{Float64}: # 2.8414709848078967 # 8.909297426825681 # 18.14112000805987 주의 #자세한 이유는 모르나 인덱스를 1부터 시작하는걸로 보인다 #인텍스를 0으로 해서 첫번째 요소를 읽을라고 하면 오류가 발생한다. julia\u0026gt; x[0] #output #ERROR: BoundsError: attempt to access 5-element Vector{Int64} at index [0] #Stacktrace: # [1] getindex(A::Vector{Int64}, i1::Int64) # @ Base ./array.jl:801 # [2] top-level scope # @ REPL[38]:1 참고 매뉴얼\n","permalink":"http://example.org/posts/julia/2-dot_operator/","summary":"julia에 dot 연산자라고, 배열안의 요소별로 각각 연산해주는것이 있다. 예시로 백터를 생성후 요소값들을 각각 하나씩 더하고 싶을때 보통은 for문등 방법을 사용하는게 보통이다.\njulia\u0026gt; x = [1,2,3,4,5] #output #5-element Vector{Int64}: # 1 # 2 # 3 # 4 # 5 julia\u0026gt; i = 1 julia\u0026gt; while i \u0026lt;= 5 x[i] = x[i]+2 global i += 1 end julia\u0026gt; x #output #5-element Vector{Int64}: # 3 # 4 # 5 # 6 # 7 허나 julia에서는 dot 연산자를 사용해 한줄코드로 간단하게 사용할수 있다.","title":"julia-'dot 연산자'"},{"content":"julia 공식 매뉴얼에서 변수 관련 문서를 보고 코드를 작성하면서 몇가지 특징을 알게 되었다.\n첫째로 요즘 언어들도 갖고있는 특성이지만 유니코드를 지원하여, 한글로 변수명이 가능하다는것과 심지어 특수기호로도 변수명이 되는걸 알수있다. 그렇다고 해서 한글 또는 특수기호로 변수명을 작성해서 사용하는건 비추천한다, 왜냐하면 julia는 이름 규칙이 따로 존재하기 때문이다.\njulia 명명 규칙 (발번역 주의)  변수명은 소문자로 한다 #example name = \u0026quot;Sunken Ahn\u0026quot;  단구 구분은 언더바(_)로 구분, 단 이름이 읽기 어려운게 아니면 사용은 자세 #example my_name = \u0026quot;Sunken Ahn\u0026quot;  모듈,타입은 단어 시작을 대문자로, 단어구분도 단어 첫글자를 대문자로 하여 구분 #example struct Foo bar baz end foo = Foo(1,2)  함수, 매코르는 언더바(_)없이 소문자 #example function f(x,y) x + y end  인수로 쓰는 함수(\u0026ldquo;mutating\u0026rdquo; or \u0026ldquo;in-place\u0026rdquo; functions)는 이름이 !로 끝나야 한다 #example function first_element_change_one!(v::Vector{Int64}) v[0] = 1 end   참고 매뉴얼 : variables\n","permalink":"http://example.org/posts/julia/1-variables/","summary":"julia 공식 매뉴얼에서 변수 관련 문서를 보고 코드를 작성하면서 몇가지 특징을 알게 되었다.\n첫째로 요즘 언어들도 갖고있는 특성이지만 유니코드를 지원하여, 한글로 변수명이 가능하다는것과 심지어 특수기호로도 변수명이 되는걸 알수있다. 그렇다고 해서 한글 또는 특수기호로 변수명을 작성해서 사용하는건 비추천한다, 왜냐하면 julia는 이름 규칙이 따로 존재하기 때문이다.\njulia 명명 규칙 (발번역 주의)  변수명은 소문자로 한다 #example name = \u0026quot;Sunken Ahn\u0026quot;  단구 구분은 언더바(_)로 구분, 단 이름이 읽기 어려운게 아니면 사용은 자세 #example my_name = \u0026quot;Sunken Ahn\u0026quot;  모듈,타입은 단어 시작을 대문자로, 단어구분도 단어 첫글자를 대문자로 하여 구분 #example struct Foo bar baz end foo = Foo(1,2)  함수, 매코르는 언더바(_)없이 소문자 #example function f(x,y) x + y end  인수로 쓰는 함수(\u0026ldquo;mutating\u0026rdquo; or \u0026ldquo;in-place\u0026rdquo; functions)는 이름이 !","title":"julia-'이름 규칙'"},{"content":"최근들어 알고리즘, 영어, 수치 해석, 정보 처리 기사 공부들이 하기 힘들어서 구글링을 하며 시간을 보내던중, 스택오버플로우 2020 survey에서 개발하고 있고, 또는 개발하고 싶은 언어 상위권을 보던도중 julia라는 새로보는 언어가 있는걸 알게되고, 요즘 공부도 별로 안되니 취미로써(?) 해당 언어를 배우기로 결정하였다.\njulia 언어 해당 언어에 대해 알아본 결과 수치해석에 사용하는 프로그래밍 언어로 보인다. 또한 공식 사이트에서 해당 언어의 장점이 설명되있는데 부족한 영어실력으로 발변역을 해본결과..  Fast : 높은 성능에 맞쳐 디자인 하였으며, LLVM를 통해 효과적으로 멀티 플랫품에서 네이티브 코드로 컴파일 하였습니다. Dynamic : 스크립트 언어처럼 동적타입 언어이다. General : 비동기 I/O,메타 프로그래밍, 디버깅등을 제공한다.  등 다른 장점들을 구루 갖춘 언어인걸 알수있다.\n실행 환경 julia를 자습하기위해 설치를 해야하겠지만, 아직 기초만 배울 생각이고 계속 사용할지는 의문이라, 사용후 제거하기 편하고, 또한 설치가 편한(?) host(윈도우)가 아닌 docker로 리눅스 이미지 환경을 구축후 해당 환경에 설치하여 사용하기로 마음 먹었다. 실행환경 : docker 이미지 : 페도라 34 앞으로 해당 언어를 자습하다가, 뭔가 새롭게 느껴지는게 있으면 복습 및 저장용으로 블로그에 글을 올릴 생각이다.\n참고  stackoverflow 2020 developer survery julia offical website  ","permalink":"http://example.org/posts/julia/0-intro/","summary":"최근들어 알고리즘, 영어, 수치 해석, 정보 처리 기사 공부들이 하기 힘들어서 구글링을 하며 시간을 보내던중, 스택오버플로우 2020 survey에서 개발하고 있고, 또는 개발하고 싶은 언어 상위권을 보던도중 julia라는 새로보는 언어가 있는걸 알게되고, 요즘 공부도 별로 안되니 취미로써(?) 해당 언어를 배우기로 결정하였다.\njulia 언어 해당 언어에 대해 알아본 결과 수치해석에 사용하는 프로그래밍 언어로 보인다. 또한 공식 사이트에서 해당 언어의 장점이 설명되있는데 부족한 영어실력으로 발변역을 해본결과..  Fast : 높은 성능에 맞쳐 디자인 하였으며, LLVM를 통해 효과적으로 멀티 플랫품에서 네이티브 코드로 컴파일 하였습니다.","title":"julia-'julia 이란?'"},{"content":"여가시간에 프로그래밍 정보를 얻어보고자 stackoverflow에서 상당히 좋은글을 보게 되었다.\n보통 코딩을 할때 \u0026ldquo;n개의 정수배열에서 y 보다 작거나 같은 Xn을 서로 합하여라\u0026rdquo; 라는 문제가 있을경우 보통 이렇게 코드를 작성하게 된다.\n//cpp 예시코드 for(int i;i\u0026lt;=array_size;i++) { int x = array[i]; if(x \u0026lt;= y) { sum += x; } } 이렇게 해당 소스코드를 작성할것이다.\n해당 소스코드는 1개의 if,한개의 비교연산자를 이용하여 x가 y보다 작거나 같으면, sum 변수에 더한다 라는 간단한 기능이 구현되어있다,그럼 여기서 어떻게 해야 성능 최적화가 되는건가?그것에 대한 답은 바로 비트연산에 있다.\n※비트연산이란? 비트 연산(bitwise operation)은 한 개 혹은 두 개의 이진수에 대해 비트 단위로 적용되는 연산이다. 일단 해답 코드를 이해하기 위해 사전정보로써 다음과 같은정보를 알고 있어야한다.  (x \u0026lt; y)에서 x-y를 하면 값은 음수다. 32비트 정수에서 음수값을 right shift로 31번 쉬프트하면 32비트들이 다 1로 바낀다. 32비트 정수에서 양수값을 right shift로 31번 쉬프트하면 32비트들이 다 0으로 바낀다. not 비트연산자를 사용하면 비트값이 반전된다 and 비트연산자는 두개의 비트값이 1일때, 결과값이 1이다.  다 해당 정보들을 외워놨으면 다음 코드가 이해할수 있을거다.\n//cpp 예시코드 { int tmp = (y-x) \u0026gt;\u0026gt; 31; /* 만약 tmp의 비트값이 전부 1이면 not연산자로 인해 0로 전부 바끼며, 0으로 and연산 하면 결과값이 0임으로 결국 sum에 0을 더한다. 즉 아무것도 더하기 않은것과 동일한 결과가 나온다. */ sum += ~tmp \u0026amp; x; } 해당 코드는 if문도 없고,비교연산자가 없지 작동이 가능하지만, 그것만으로 성능이 더 좋아질수 있을까라고 생각할것이다. 그래서 다음같은 조건으로 테스트를 해보았다.\n테스트 기기 기기이름 : 라즈베리파이4 모델 B CPU : 1.5GHz ARM Cortex-A72 MP4 RAM : 8GB LPDDR4 프로그램 조건  10000000개의 정수배열 배열의 각 요소값은 랜덤 1562값보다 작을경우 더하여, 출력  if문을 사용한 코드 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;time.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; const int count = 10000000; const int cut = 1562; int main() { srand(time(NULL)); clock_t s,l; int i = 0; int sum = 0; int *datas = (int*)malloc(sizeof(int)*count); for(;i\u0026lt;count;i++) { datas[i] = rand(); } i=0; s = clock(); //-----------테스트 코드 -------------- do { i++; if(datas[i] \u0026lt;= cut) sum += datas[i]; }while(i\u0026lt;count); //------------------------------------- l = clock(); printf(\u0026quot;time : %0.3lf(sec) \u0026quot;, (double)(l-s)/CLOCKS_PER_SEC); printf(\u0026quot;sum : %d\\n\u0026quot;,sum); return 0; } 결과 비트연산을 사용한 코드 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;time.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; const int count = 10000000; const int cut = 1562; int main() { srand(time(NULL)); clock_t s,l; int i = 0; int sum = 0; int *datas = (int*)malloc(sizeof(int)*count); int temp=0; for(;i\u0026lt;count;i++) { datas[i] = rand(); } i=0; s = clock(); //-------------- 테스트 코드 -------------------- do { i++; /* / same / if(datas[i] \u0026lt; cut) / sum += datas[i]; */ temp = (cut - datas[i]) \u0026gt;\u0026gt; 31; sum += ~temp \u0026amp; datas[i]; }while(i\u0026lt;count); //----------------------------------------------- l = clock(); printf(\u0026quot;time : %0.3lf(sec) \u0026quot;, (double)(l-s)/CLOCKS_PER_SEC); printf(\u0026quot;sum : %d\\n\u0026quot;,sum); return 0; } 결과 결론 테스트 결과 대략 5배정도 차이나는 놀라운 성능 최적화를 보여주였다. 이렇게 비트 연산을 사용하여 최적화한 글을 적어보면서, 프로그램 최적화는 끝은 없다고 생각하게 되었다. 이렇게 코드를 최적화하는 방법을 찾아보며, 포스트글을 적으면서 공부하는것도 나쁘지 않다고 생각하며 해당글은 여기서 마치겠습니다.\n참고 비트연산이란? : 위키백과\n라즈베리파이4 모델 b 사양 : 공식사이트\n해당 게시글(정확한 주제는 분기예측이다) : stack overflow\n","permalink":"http://example.org/posts/optimizing_the_if_less_operator/","summary":"여가시간에 프로그래밍 정보를 얻어보고자 stackoverflow에서 상당히 좋은글을 보게 되었다.\n보통 코딩을 할때 \u0026ldquo;n개의 정수배열에서 y 보다 작거나 같은 Xn을 서로 합하여라\u0026rdquo; 라는 문제가 있을경우 보통 이렇게 코드를 작성하게 된다.\n//cpp 예시코드 for(int i;i\u0026lt;=array_size;i++) { int x = array[i]; if(x \u0026lt;= y) { sum += x; } } 이렇게 해당 소스코드를 작성할것이다.\n해당 소스코드는 1개의 if,한개의 비교연산자를 이용하여 x가 y보다 작거나 같으면, sum 변수에 더한다 라는 간단한 기능이 구현되어있다,그럼 여기서 어떻게 해야 성능 최적화가 되는건가?","title":"비교연산자가 포함된 if문을 비트연산으로 변화"},{"content":"","permalink":"http://example.org/about/","summary":"","title":""}]