<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>정리노트 on Sunken Ahn Blog</title>
    <link>https://devsanso.github.io/tags/%EC%A0%95%EB%A6%AC%EB%85%B8%ED%8A%B8/</link>
    <description>Recent content in 정리노트 on Sunken Ahn Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>kr-ko</language>
    <lastBuildDate>Tue, 23 Nov 2021 23:58:33 +0900</lastBuildDate><atom:link href="https://devsanso.github.io/tags/%EC%A0%95%EB%A6%AC%EB%85%B8%ED%8A%B8/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>코틀린 하면서 느낀 infix 유용함</title>
      <link>https://devsanso.github.io/posts/kotlin/useful_infix_fun/</link>
      <pubDate>Tue, 23 Nov 2021 23:58:33 +0900</pubDate>
      
      <guid>https://devsanso.github.io/posts/kotlin/useful_infix_fun/</guid>
      <description>코틀린으로 spring 프로젝트를 코딩하고 있는데, 데이터베이스를 사용해야해서 JetBrains(코틀린 만든회사)에서 만든 exposed 라는 sql프레임워크를 사용하게 되었다.
그렇게 해당 라이브러리로 테이블 객체를 만들고, select를 수행하는 함수에서 where 문을 추가해야 하는 상황에서 infix 함수를 사용하게 되었다.
일단 예시로 평소에 나는 이렇게 코딩하고 있었다
/* ... ... ... */ data class User : Table() (val name : String,val age : Int,/*..*/) data class NameAndAge(/*..*/) fun selectUser() : List&amp;lt;NameAndAge&amp;gt; { //select 안에 where 관련 기능이 추가된다.</description>
    </item>
    
    <item>
      <title>모듈 임포트</title>
      <link>https://devsanso.github.io/posts/rust/how_import_modules/</link>
      <pubDate>Thu, 04 Nov 2021 22:14:44 +0900</pubDate>
      
      <guid>https://devsanso.github.io/posts/rust/how_import_modules/</guid>
      <description>러스트로 코딩하는도중, 소스코드를 분리할 필요성을 느껴 별도의 모듈로 만들고나서 임포트 할려고 할때, 해당 프로젝트안의 로컬 모듈들을 어떻게 임포트 하는지, 기억하기 힘들어 따로 이렇게 글을 작성할 필요성을 느꼇다.
러스트에서는 mod라는 키워드가 있는데, 해당 키워드는 두가지의 기능을 수행한다.
 c++.c#처럼 네임스페이스 비슷한 기능을 한다. 다른 모듈들을 인클루드 한다. 예시로 이런 코드가 있다고 치자  // path : src/main.rs  /* similar c++ namespace module { void hello() { std::cout &amp;lt;&amp;lt; &amp;#34;hello world&amp;#34; &amp;lt;&amp;lt; std::endl; } }; int main() { module::hello(); return 0; } */ mod module { pub fn hello() { println!</description>
    </item>
    
    <item>
      <title>trait를 리턴하는 방법</title>
      <link>https://devsanso.github.io/posts/rust/how_return_trait/</link>
      <pubDate>Sat, 30 Oct 2021 13:09:42 +0900</pubDate>
      
      <guid>https://devsanso.github.io/posts/rust/how_return_trait/</guid>
      <description>러스트로 코딩하던 도중에 트레이드를 리턴해야하는 함수를 만들어야 하는 상황이 있었다. 그래서 go언어를 코딩하는것과 마찬가지로 리턴타입을 트레이드(go언어에선 인터페이스)로 하여 리턴 하는 함수를 작성후 컴파일 해본적이 있었는데 그때의 일을 적어볼려고 한다.
//go 코드 예시 package main import &amp;#34;fmt&amp;#34; type Hi interface { hi() } type String struct { s string } func new_hi(s string) Hi { return &amp;amp;String{s} } func (s *String)hi() { fmt.Println(&amp;#34;hi : &amp;#34;s.s) } func main() { var str = &amp;#34;sunken ahn&amp;#34; new_hi(str).</description>
    </item>
    
  </channel>
</rss>
